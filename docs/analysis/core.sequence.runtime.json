{
  "core.sequence.runtime.ActiveSequence": {
    "ActiveSequence(SequenceDefinition, AbilityConfig)": "Constructor for the runtime manager of a specific sequence. It takes the parsed `SequenceDefinition` (the AST) and the `AbilityConfig`. Its key function is to call `indexInstances`, which traverses the entire AST to create a unique, predictable ID for every single ability token in the sequence (e.g., 'ability_a#0', 'ability_a#1'). This pre-indexing is crucial for the `DetectionEngine` to request and receive detections for specific occurrences of an ability. It also initializes the `StepTimer`. It is called by `SequenceManager` when a sequence is activated.",
    "getDetectionRequirements()": "This is a key performance-related method that provides the `DetectionEngine` with a list of all abilities that need to be detected in the current frame. It intelligently gathers the unique ability instances for both the current and the *next* step. This 'lookahead' allows the `DetectionEngine` to find and cache the locations of abilities for the next step before they are strictly needed, ensuring smoother transitions and better performance. It returns a list of `DetectionRequirement` records.",
    "processDetections(List<DetectionResult>)": "The main entry point for updating the sequence's state based on a new frame's worth of detection results. It receives a list of `DetectionResult`s from the `DetectionEngine`, stores them in an internal map for quick lookup, and then asks the `StepTimer` if the current step is satisfied (i.e., if enough time has passed). If the step is satisfied, it advances to the next step or marks the sequence as complete.",
    "onStateChanged(SequenceController.State, State)": "Implementation of the `StateChangeListener` interface. This method is called by the `SequenceController` whenever the global application state changes. Its sole purpose is to pause or resume the internal `StepTimer`. When the state becomes `RUNNING`, it resumes the timer; for any other state, it pauses it. This ensures that the step timers do not advance while the application is not in an active running state.",
    "indexInstances(SequenceDefinition)": "A private method called by the constructor to perform a critical pre-processing step. It traverses the entire `SequenceDefinition` AST and creates a unique, stable `AbilityInstance` ID for every single ability token, accounting for duplicates (e.g., 'Fireball#0', 'Fireball#1'). This unique ID is essential for the `DetectionEngine` to request and process detections for a specific occurrence of an ability within the sequence. All instances are stored in maps for quick lookup."
  },
  "core.sequence.runtime.StepTimer": {
    "startStep(Step, AbilityConfig)": "This method is called by `ActiveSequence` whenever a new step begins. It resets and starts the timer for the current step. Its most important task is to call `calculateStepDuration` to determine how long this step should last based on the abilities it contains (considering cast times, cooldowns, and the global cooldown). It records the start time, allowing `isStepSatisfied` to check for completion.",
    "isStepSatisfied(Map<String, DetectionResult>)": "This method is called by `ActiveSequence` on every detection frame to check if the current step is complete. It calculates the effective elapsed time since the step started, correctly accounting for any time the timer was paused (via `totalPausedTimeMs`). It returns `true` if this elapsed time is greater than or equal to the pre-calculated `stepDurationMs`, signaling that it's time to advance to the next step.",
    "pause()": "Pauses the step timer. It records the timestamp when the pause began and sets a flag. This is called by `ActiveSequence` when the global application state is anything other than `RUNNING`, ensuring that the timer does not advance when the sequence is not active.",
    "resume()": "Resumes a paused timer. It calculates the duration of the pause (the difference between the current time and `pausedAtMs`) and adds it to `totalPausedTimeMs`. This ensures that the `isStepSatisfied` method can accurately calculate the effective elapsed time by subtracting all paused intervals. This is called by `ActiveSequence` when the global state transitions to `RUNNING`.",
    "calculateStepDuration(Step, AbilityConfig)": "A private helper that calculates the total duration, in milliseconds, for a given `Step`. It iterates through all the abilities within the step and, for each one, determines its effective 'off-screen' time, which is the maximum of its cast time, its own cooldown, or the global cooldown (GCD). The duration of the entire step is then set to the maximum effective time of any single ability within it. This logic dictates the pacing of the entire sequence."
  }
}