{
  "application.SequenceController": {
    "SequenceController(SequenceManager)": "Constructor for the central state machine of the application. It takes the `SequenceManager` as a dependency, which it orchestrates based on user hotkey inputs. It initializes the state to `READY` and prepares to manage listeners. This class acts as the bridge between raw user input (hotkeys) and the high-level management of the active sequence's lifecycle. It is called by `Main` during startup.",
    "onStartSequence()": "A synchronized callback method triggered by the `HotkeyManager` upon the 'start' hotkey event. It transitions the application state from `READY` to `ARMED`, which signifies that the controller is now waiting for a specific in-game visual cue (a 'latch') before beginning the actual sequence timing. This two-stage start prevents premature activation. It calls `setState` to manage the transition and notify listeners. Known issue: if the latch is never detected, the application remains `ARMED` indefinitely.",
    "onRestartSequence()": "A synchronized `HotkeyListener` callback for the 'restart' hotkey. It immediately resets the currently active sequence via the `SequenceManager.resetActiveSequence()` call and puts the controller back into the `ARMED` state. This provides a quick way for users to restart the sequence from the beginning without needing to manually stop and start. It is called by the `HotkeyManager`.",
    "onSequenceCompleted()": "A synchronized callback method invoked by the `SequenceManager` when the active sequence has finished all its steps. It transitions the state from `RUNNING` back to `READY`, preparing the application for a new run. This provides a clean conclusion to the sequence and ensures the state machine is reset. It is called exclusively by `SequenceManager`.",
    "getState()": "A simple, synchronized getter that provides thread-safe, volatile access to the `currentState` variable. This allows other components, particularly UI elements, to query the current status of the sequence (e.g., `READY`, `RUNNING`) without direct field access, ensuring a consistent and up-to-date value.",
    "isRunning()": "A synchronized convenience method that returns `true` only if the controller's current state is `RUNNING`. This provides a clear, readable API for other components, like the `DetectionEngine`, to quickly check if the sequence is active, which determines whether they should perform their work. It is a safer alternative to external components comparing enum states directly.",
    "isArmed()": "A synchronized convenience method returning `true` if the state is `ARMED`. This is used by the `SequenceManager`'s internal `GcdLatchTracker` to know when it should be looking for the visual 'latch' that will trigger the transition to the `RUNNING` state. This simplifies the logic for components that only care about this specific intermediate state.",
    "resetToReady()": "A synchronized helper that forces the controller back into the READY state regardless of its previous state. It delegates the transition to `setState(State.READY)` so that listeners are notified through the same centralized mechanism and logging remains consistent. Higher-level orchestration, such as `SequenceRunService`, calls this when restarting from a paused state so that the next start request begins from a clean, READY baseline instead of reusing an old state.",
    "setPaused()": "A synchronized method that transitions the controller into the PAUSED state by delegating to `setState(State.PAUSED)`. It is invoked by services that respond to user pause actions, ensuring downstream listeners observe a dedicated PAUSED state rather than RUNNING or READY. This allows UI components, including the Preset Manager master panel, to reflect pause status accurately and prevents new latch events from advancing the active sequence while the system is paused.",
    "onLatchDetected()": "A synchronized callback method invoked by the `SequenceManager` when it detects the visual cue confirming in-game abilities are ready. This method transitions the state from `ARMED` to `RUNNING`, which starts the timers and active detection for the sequence steps. This is the final step in the sequence initiation process.",
    "setState(State)": "A private, synchronized method that is the sole entry point for changing the `currentState`. It ensures that a state change only proceeds if the new state is different from the current one, preventing redundant notifications. It updates the volatile `currentState` and then calls `notifyStateChange` to inform all registered listeners of the transition. This centralization is crucial for maintaining state consistency.",
    "addStateChangeListener(StateChangeListener)": "A public method that allows other components to register for state change notifications. It adds the provided `StateChangeListener` to a list of listeners. This observer pattern enables components like `ActiveSequence` and `SequenceManager` to react to state transitions (e.g., pausing timers) without being tightly coupled to the `SequenceController`. It is called by `SequenceManager` and `ActiveSequence`.",
    "removeStateChangeListener(StateChangeListener)": "Allows a component to unregister from state change notifications by removing it from the list of listeners. This is important for proper resource management, especially when components are being destroyed or replaced, to prevent memory leaks and unnecessary callbacks. It is called by `SequenceManager` when a new controller is set or a sequence is deactivated.",
    "notifyStateChange(State, State)": "A private helper method that iterates through all registered `StateChangeListener`s and invokes their `onStateChanged` method. It is called by `setState` whenever a state transition occurs. The method includes error handling to ensure that a faulty listener does not prevent other listeners from being notified, which adds robustness.",
    "StateChangeListener.onStateChanged(State, State)": "This defines the single method of the `StateChangeListener` functional interface, part of the observer pattern. It is implemented by classes that need to react to the application's lifecycle, such as `ActiveSequence` (to pause its timers) and `SequenceManager` (to manage its `GcdLatchTracker`). It receives the old and new states, allowing for conditional logic based on the transition."
  },
  "application.SequenceManager": {
    "SequenceManager(Map<String, SequenceDefinition>, AbilityConfig)": "Constructor for the central orchestrator of sequence logic. It requires a map of all available, pre-parsed sequences (`namedSequences`) and the `AbilityConfig`. It initializes its internal state, including the `GcdLatchTracker`, which is used to synchronize the start of a sequence with in-game events. This manager is responsible for holding the `ActiveSequence` and delegating detection results to it. It is called by `Main` at startup.",
    "setSequenceController(SequenceController)": "Sets the `SequenceController` for this manager, establishing a bidirectional communication link. It registers itself as a `StateChangeListener` on the new controller, allowing it to react to global state changes like 'ARMED'. It also gracefully unregisters from any previous controller. This dependency injection is crucial for decoupling the high-level state machine from the sequence execution logic. It is called by `Main` during initialization.",
    "activateSequence(String)": "Activates a new sequence by its name by looking up the corresponding `SequenceDefinition`. If found, it creates a new `ActiveSequence` instance, which becomes the current runtime for the sequence. It also registers the new `ActiveSequence` as a state change listener on the `SequenceController`. This is the primary method for selecting which sequence is ready to be run, and is called by `Main` after parsing the user's selected rotation from config.",
    "getDetectionRequirements()": "A key performance-related method that provides the `DetectionEngine` with a list of all abilities that need to be detected in the current frame. It delegates this request to the `ActiveSequence`, which intelligently provides abilities for both the current and the next step. This 'lookahead' allows the engine to cache ability locations before they are strictly needed, ensuring smoother transitions between steps. Returns an empty list if no sequence is active.",
    "processDetection(List<DetectionResult>)": "The main entry point for processing a new frame's worth of detection results from the `DetectionEngine`. This synchronized method first passes the results to the internal `GcdLatchTracker` to check if a visual 'latch' has occurred (to start a sequence). It then forwards the results to the `ActiveSequence` to advance its state machine. If the sequence reports completion, this method calls `onSequenceCompleted` to finalize the run.",
    "getCurrentAbilities()": "A synchronized accessor method that retrieves the list of `DetectionResult` objects for the abilities in the currently active step. It delegates the call to the `activeSequence`. This data is used by the `OverlayRenderer` to provide real-time visual feedback to the user, highlighting which abilities are currently required.",
    "getNextAbilities()": "A synchronized accessor, similar to `getCurrentAbilities`, but for the *next* step in the sequence. It delegates to the `activeSequence` to get this lookahead information. This is used by the `OverlayRenderer` to show the user which abilities they should prepare for next, a core feature of the application.",
    "getActiveSequenceAbilityKeys()": "Returns a list of all unique ability keys used anywhere in the currently active sequence. It delegates to the `activeSequence`. This is primarily used at the beginning of a sequence run to allow the `DetectionEngine` to 'prime' its cache by finding and storing the locations of all relevant abilities in a single pass.",
    "addNamedSequence(String, SequenceDefinition)": "A synchronized method that allows for the dynamic addition of new sequences to the manager after initialization. It takes a name and a parsed `SequenceDefinition` and adds them to the internal `namedSequences` map. This could be used for features like importing new sequences at runtime.",
    "resetActiveSequence()": "Resets the state of the currently active sequence, returning it to its first step. It delegates this call to the `activeSequence.reset()` method and also clears the `sequenceComplete` flag. This is typically triggered by the user pressing the 'restart' hotkey, via the `SequenceController`.",
    "hasActiveSequence()": "A simple synchronized predicate method that returns `true` if there is currently an `activeSequence` loaded. This is used by other components to check if a sequence is ready to be run before attempting operations.",
    "isSequenceComplete()": "A synchronized accessor for the `sequenceComplete` flag. This provides a way for external components to check if the current sequence has finished all its steps without needing to query the `ActiveSequence` directly.",
    "shouldDetect()": "A synchronized predicate method that returns `true` if the `DetectionEngine` should currently be performing image recognition. It returns true only if there is an active sequence and that sequence is not yet complete. This is the primary control signal for the main detection loop in `DetectionEngine`.",
    "onStateChanged(SequenceController.State, SequenceController.State)": "Implementation of the `StateChangeListener` interface. This method is called by the `SequenceController` when the global application state changes. It forwards the state change to its internal `GcdLatchTracker`, which uses this information to manage its own state (e.g., starting to look for a visual latch when the app becomes 'ARMED').",
    "onSequenceCompleted()": "A private method called internally when `processDetection` determines the sequence is finished. It sets the `sequenceComplete` flag to true, resets the `GcdLatchTracker`, and notifies the `SequenceController`. This ensures the application cleanly transitions back to a `READY` state.",
    "GcdLatchTracker.onStateChanged(SequenceController.State)": "This method within the private `GcdLatchTracker` class is the entry point for state changes from the parent `SequenceManager`. Its primary role is to trigger the 'latching' process. When the new state is `ARMED`, it resets its internal state machine, preparing to watch for a fresh ability cooldown cycle. For any other state, it calls its own `reset` method to clear tracking.",
    "GcdLatchTracker.onFrame(List<DetectionResult>)": "This is the core logic method for the `GcdLatchTracker`, called on every detection frame while the application is ARMED. It first verifies that a valid frame and controller exist. If it is still waiting for an initial snapshot, it calls `beginTracking` to lock in bright, GCD-triggering abilities as tracked targets. Once targets are established, it samples brightness for each region every frame and lets each `TrackedTarget` update its darkening status. When all tracked targets have darkened enough, it calls `latch()` to transition the sequence to RUNNING.",
    "GcdLatchTracker.beginTracking(Map<String, DetectionResult>)": "This private helper within `GcdLatchTracker` is invoked when the tracker is ARMED and receives its first suitable video frame. It selects up to two abilities flagged as triggering the global cooldown (GCD) from the active sequence’s detection requirements, resolves their on-screen regions via the `TemplateDetector`, and measures a baseline brightness for each. If every candidate has a valid region and exceeds a minimum brightness threshold, it records them as `TrackedTarget`s, switches into 'waiting for darken' mode, and logs the baselines.",
    "GcdLatchTracker.latch()": "A private method within `GcdLatchTracker` that finalizes the latching process once all tracked abilities have darkened for enough consecutive frames. It first checks that the tracker is still waiting for darkening and that a `SequenceController` is present. It captures the current time, optionally restarts the active sequence’s `StepTimer` so timing aligns with the visual latch, resets its own internal state, notifies the controller via `onLatchDetected()`, and shows a success notification.",
    "GcdLatchTracker.TrackedTarget.update(DetectionResult)": "This method within the nested `TrackedTarget` class updates the darkening status for a single watched ability tile using sampled brightness values. It compares the latest brightness to the stored baseline, computes the relative drop, and increments a counter whenever the drop exceeds a configured threshold. After a required number of consecutive dark frames, it marks the tile as darkened. If brightness recovers or samples are invalid, it resets the counter. The parent tracker relies on this flag to detect when all targets have latched."
  },
  "application.TemplateCache": {
    "TemplateCache(Path)": "Primary constructor for the `TemplateCache`. It takes a `Path` to the directory containing the ability icon images. It initializes a thread-safe `ConcurrentHashMap` for caching and immediately calls its `initialize()` method to synchronously load all image templates from the specified path into memory. This ensures the cache is fully populated at startup. It is called by other constructors within the class and is central to the application's boot sequence.",
    "TemplateCache(String, int)": "A convenience constructor that resolves the default image path based on an application name and a UI scaling percentage. It calls the `resolveDefaultImagePath` static helper to determine the correct subfolder for pre-scaled icons (e.g., '.../Abilities/30' for 100% scaling). It then delegates to the primary `TemplateCache(Path)` constructor. This is the main constructor used by `Main` during application startup.",
    "initialize()": "This method is responsible for loading all image files from the configured `imagePath` into the cache. It lists the files in the directory, filters for common image extensions, and for each valid file, it calls `cacheTemplate`. This is a synchronous, blocking operation that runs on startup to ensure all templates are available before the detection engine starts. Throws a `RuntimeException` on `IOException`. It is called by the `TemplateCache` constructor.",
    "cacheTemplate(String, Path)": "A private helper that loads a single image file from disk into an OpenCV `Mat` object. If the load is successful, it creates a new `TemplateData` object (which clones the `Mat`) and puts it in the thread-safe cache map. Crucially, it immediately calls `close()` on the original `Mat` to release its native resources, preventing memory leaks. This is a core part of the `initialize` loop.",
    "getTemplate(String)": "The primary public method for retrieving a template from the cache. It takes an ability name as a key and returns the corresponding OpenCV `Mat` object if it exists in the cache, or `null` otherwise. This provides a fast, thread-safe lookup for the `TemplateDetector`, and is called frequently during the detection loop.",
    "shutdown()": "A crucial resource cleanup method that must be called when the application is closing. It iterates through all the `TemplateData` objects in the cache and calls their `close()` method, which in turn releases the native memory of each OpenCV `Mat`. It also shuts down the internal `ExecutorService`. This is called by the shutdown hook in `Main` to prevent memory leaks."
  }
}
