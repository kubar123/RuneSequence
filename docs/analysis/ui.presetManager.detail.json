{
  "ui.presetManager.detail.SequenceDetailService": {
    "createAbilityItem(String)": "A factory method that converts a raw ability key (a string) into a rich `AbilityItem` object. It fetches the ability's metadata (like display name, level) from the `AbilityConfig` and loads its icon using the `AbilityIconLoader`. This service acts as a bridge between the raw configuration data and the UI-specific models needed for rendering.",
    "saveSequence(...)": "This method handles the business logic for saving a sequence. It takes the sequence's name and its expression string, resolves its unique ID, and then updates the `RotationConfig` object. Finally, it calls `configManager.saveRotations()` to persist the changes to disk. It returns a `SaveOutcome` object, which indicates success or failure and provides appropriate user-facing messages. This is called by the `SequenceDetailPresenter`."
  },
  "ui.presetManager.detail.SequenceDetailPresenter": {
    "SequenceDetailPresenter(...)": "Constructor for the presenter in the detail editor's MVP layer. It takes the `SequenceDetailService` model, the `AbilityFlowView` responsible for rendering cards, and a `View` facade implemented by `SequenceDetailPanel`. It creates an `ExpressionBuilder`, initializes empty element lists, and attaches itself as the `DragCallback` via `AbilityFlowView.attachDragController`. From that point on it owns all sequencing logic, keeping UI components thin and testable.",
    "loadSequence(...)": "Called whenever the detail panel should display a specific preset. It stores the current preset ID and data, copies the name into the view, and parses the expression string into `SequenceElement`s using `detailService.parseSequenceExpression`. The parsed list is cached as both the “loaded” baseline and the working list, and then rendered via `flowView.renderSequenceElements`. These cached values drive later discard and unsaved-change checks.",
    "saveSequence()": "The handler behind the Save button. It trims the sequence name from the view, builds an expression string from `currentElements` via `ExpressionBuilder`, and calls `detailService.saveSequence`. On validation or persistence failure it chooses an appropriate `JOptionPane` message level and asks the view to display the error. On success it updates the in-memory `PresetData`, refreshes the loaded baseline fields, notifies registered `SaveListener`s, and shows a success message through the view.",
    "discardChanges()": "Restores the editor to the last successfully loaded or saved state. It rewrites the bound `PresetData`'s name and expression to the cached baseline values, replaces `currentElements` and `previewElements` with copies of the original element list, updates the text field through `view.setSequenceName`, and re-renders the flow view. This is used both by the Discard button and by callers that want to reset the form before switching presets.",
    "hasUnsavedChanges()": "Determines whether the user has modified the current preset since it was last loaded or saved. It compares the trimmed sequence name in the view against the cached `loadedSequenceName`, then builds an expression from `currentElements` and compares it to the original `loadedExpression`. Any difference in either field is treated as unsaved work, which informs auto-save behavior in `PresetManagerWindow`.",
    "onDragStart(...)": "Implementation of the `DragCallback` entry point for drag lifecycles. It clears any existing preview, resets drag-outside state on the view, and snapshots the current element list so a cancellation can restore it exactly. It resolves which `SequenceElement` corresponds to the dragged item (handling both ability cards and tooltip cards) and uses `ExpressionBuilder` to build a preview list that omits that occurrence. Palette-originated drags keep the current list unchanged.",
    "onDragMove(AbilityItem, DragPreviewModel)": "Called on every preview tick with a `DragPreviewModel` produced by the drag engine. It converts the cursor position from flow-panel coordinates into the detail view to detect when the user has dragged outside the panel, toggling the drag overlay\'s trash state accordingly. When the pointer is still inside and the preview is valid it forwards the model to `AbilityFlowView.applyPreviewModel` to highlight the predicted drop target; otherwise it clears any highlight and hides empty-panel indicators.",
    "onDragEnd(AbilityItem, boolean)": "Finalizes or cancels the drag at mouse release. It uses the last `DragPreviewModel` and an internal flag that tracks whether a highlight was active to decide if the drop should be committed, treated as a trash delete, or discarded. It handles commits for abilities, sequences (clipboard), and tooltips by calling the appropriate `ExpressionBuilder` insert method. In all cases it refreshes the lists, updates the backing `PresetData` expression, and re-renders the view.",
    "editTooltipAt(int)": "A callback method triggered by user interaction (e.g., double-clicking a tooltip card). It prompts the user for new text via a modal dialog, validates the input using `ExpressionBuilder`, and updates the tooltip element if valid. It handles empty input as a removal."
  },
  "ui.presetManager.detail.SequenceDetailPanel": {
    "SequenceDetailPanel(SequenceDetailService, NotificationService)": "Constructor for the main 'detail' view in the Preset Manager. It builds the name field, a compact clipboard-insert button, a Settings button placeholder, and Save/Discard buttons above a scrollable `AbilityFlowView`. The panel creates a `SequenceDetailPresenter`, passing both the `SequenceDetailService` and the injected `NotificationService`, and registers action listeners so Save and Discard delegate to presenter methods. Notification support is used for non-blocking feedback, including clipboard drag errors; when no notification implementation is available the panel falls back to simple beeps. It acts as the concrete `View` implementation that presenters and other panels interact with.",
    "startPaletteDrag(AbilityItem, JPanel, Point)": "Bridge method used by the `AbilityPalettePanel`. When the user begins dragging an ability from the palette, this method is called with the originating card and cursor position. It forwards the request to the presenter so the drag controller can treat palette-originated drops consistently with in-sequence drags, including previewing, inserting, and updating the underlying expression.",
    "discardChanges()": "Public façade for the Discard button. It simply delegates to `SequenceDetailPresenter.discardChanges`, which restores the sequence name and element list to the last loaded baseline and re-renders the flow view. `PresetManagerWindow` calls this when switching selections while auto-save is disabled so that half-edited sequences do not leak into other presets.",
    "startNewSequence(String, RotationConfig.PresetData)": "Convenience method used when adding or importing a new preset. It routes the provided ID and `PresetData` through the presenter's load path to populate the editor, then calls `highlightSequenceNameField` to focus and select the name text. This encourages the user to immediately give the new preset a meaningful title.",
    "setToastClient(ToastClient)": "Optional injection of a `ToastClient` that the panel will use for user feedback. When provided, the panel maps presenter messages and clipboard insert errors into success, warning, info, or error toasts; when absent, it falls back to standard `JOptionPane` dialogs or a simple system beep. This keeps the editor usable in both rich and minimal UI environments.",
    "clear()": "Clears the current sequence editor state. It calls through to the presenter, which resets all cached fields, empties the element lists, clears the sequence name, and re-renders the flow view with no cards. This is primarily used when the last preset is deleted from the master list.",
    "addSaveListener(SaveListener)": "Registers an observer that will be notified when the presenter completes a successful save. Listeners receive a `SaveResult` containing the final preset ID and data, allowing outer components like `PresetManagerWindow` to synchronize the master list model and selection without tightly coupling to the detail panel's internals.",
    "saveSequence()": "Imperative helper that triggers a save without going through the button's `ActionListener`. It simply forwards to the presenter's `saveSequence` method. `PresetManagerWindow` uses this during auto-save flows so that the same validation, persistence, and toast-reporting logic is reused regardless of whether the user clicked Save or switched presets.",
    "hasUnsavedChanges()": "Pass-through to `SequenceDetailPresenter.hasUnsavedChanges`. It lets the owner window ask the panel whether the currently edited preset diverges from the last loaded baseline, combining both name and expression differences. This signal is used to decide if auto-save should run when the user selects another preset.",
    "showSaveDialog(String, int)": "Implementation of the presenter's `View` interface for surfacing status messages. When a `ToastClient` is configured, it maps standard `JOptionPane` message types to success, warning, info, or error toasts without blocking the UI. If no client is available, it falls back to a modal `JOptionPane.showMessageDialog`, ensuring feedback is still visible in non-overlay environments."
  },
  "ui.presetManager.detail.ClipboardInsertItem": {
    "ClipboardInsertItem(String, String, ImageIcon, List<SequenceElement>, String)": "Constructor for a specialized `AbilityItem` that carries a parsed sequence rotation. It is used when dragging content from the clipboard insert button. Unlike a standard item which represents a single ability, this item holds a list of `SequenceElement`s and the original expression string.",
    "getElements()": "Returns the list of `SequenceElement` objects parsed from the clipboard content.",
    "getExpression()": "Returns the original raw string expression from the clipboard.",
    "isSingleAbility()": "Helper method to determine if the clipboard content consists of just a single ability (no separators). This allows the system to treat it like a standard ability drop if appropriate.",
    "isMultiStep()": "Helper method to determine if the clipboard content contains multiple steps (arrows), indicating a full rotation sequence."
  },
  "ui.presetManager.detail.AbilityGroupPanel": {
    "AbilityGroupPanel(Color)": "Constructor for a simple `JPanel` that acts as a visual container for a group of abilities that are linked by '+' (AND) or '/' (OR) operators. It uses a `FlowLayout` and sets a distinct background color and border to visually distinguish the group from standalone abilities in the `AbilityFlowView`."
  },
  "ui.presetManager.detail.AbilityCardFactory": {
    "createAbilityCard(AbilityItem)": "A factory method that creates a `JPanel` representing a single, draggable ability card in the sequence editor. It sets up the layout with an icon and a name label. Crucially, it attaches the `MouseAdapter` from the `AbilityDragController` to the card, making it draggable. It also stores the ability's key and element index as client properties for later retrieval during drag operations.",
    "createSeparatorLabel(SequenceElement)": "A factory method that creates a `JLabel` for displaying a separator (→, +, /) between ability cards in the `AbilityFlowView`."
  },
  "ui.presetManager.detail.AbilityFlowView": {
    "renderSequenceElements(List<SequenceElement>)": "The main rendering method for the sequence. It clears the panel and then iterates through the list of `SequenceElement`s. It intelligently groups consecutive abilities linked by '+' or '/' into a colored `AbilityGroupPanel` for better visual organization, while rendering standalone abilities, tooltips, and separators directly. After layout it snapshots the card components for subsequent hit-testing.",
    "attachDragController(DragCallback)": "A setup method that connects this view to the `AbilityDragController`. It creates the controller, passing itself as the container and the `SequenceDetailPresenter` as the callback. This is a critical step in enabling the drag-and-drop functionality for this component.",
    "applyPreviewModel(DragPreviewModel)": "Applies a `DragPreviewModel` produced by the drag engine to the card layout. It first clears any highlight from the previously targeted card, then, if the new model is valid, either highlights the entire empty panel or the specific target ability card using a color derived from the `DropZoneType`. It repaints only the affected region for performance and returns `true` when a highlight was applied.",
    "resetPreview()": "Clears any active drag preview from the view. It removes visual highlighting from the last targeted card, restores the panel background and border to their defaults, hides the empty-drop indicator, and forgets the cached preview reference so subsequent drags start from a clean state.",
    "createPaletteDragListener(AbilityItem, JPanel)": "Creates a `MouseAdapter` that initiates a drag operation for a given ability item and card. This method delegates to the `AbilityDragController` to create the listener, enabling the new clipboard insert button (and other palette items) to trigger the standard drag-and-drop workflow."
  }
}
