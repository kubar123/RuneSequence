{
  "ui.presetManager.detail.SequenceDetailService": {
    "createAbilityItem(String)": "A factory method that converts a raw ability key (a string) into a rich `AbilityItem` object. It fetches the ability's metadata (like display name, level) from the `AbilityConfig` and loads its icon using the `AbilityIconLoader`. This service acts as a bridge between the raw configuration data and the UI-specific models needed for rendering.",
    "saveSequence(...)": "This method handles the business logic for saving a sequence. It takes the sequence's name and its expression string, resolves its unique ID, and then updates the `RotationConfig` object. Finally, it calls `configManager.saveRotations()` to persist the changes to disk. It returns a `SaveOutcome` object, which indicates success or failure and provides appropriate user-facing messages. This is called by the `SequenceDetailPresenter`."
  },
  "ui.presetManager.detail.SequenceDetailPresenter": {
    "SequenceDetailPresenter(...)": "Constructor for the presenter in the detail editor's MVP layer. It takes the `SequenceDetailService` model, the `AbilityFlowView` responsible for rendering cards, and a `View` facade implemented by `SequenceDetailPanel`. It creates an `ExpressionBuilder`, initializes empty element lists, and attaches itself as the `DragCallback` via `AbilityFlowView.attachDragController`. From that point on it owns all sequencing logic, keeping UI components thin and testable.",
    "loadSequence(...)": "Called whenever the detail panel should display a specific preset. It stores the current preset ID and data, copies the name into the view, and parses the expression string into `SequenceElement`s using `detailService.parseSequenceExpression`. The parsed list is cached as both the “loaded” baseline and the working list, and then rendered via `flowView.renderSequenceElements`. These cached values drive later discard and unsaved-change checks.",
    "saveSequence()": "The handler behind the Save button. It trims the sequence name from the view, builds an expression string from `currentElements` via `ExpressionBuilder`, and calls `detailService.saveSequence`. On validation or persistence failure it chooses an appropriate `JOptionPane` message level and asks the view to display the error. On success it updates the in-memory `PresetData`, refreshes the loaded baseline fields, notifies registered `SaveListener`s, and shows a success message through the view.",
    "discardChanges()": "Restores the editor to the last successfully loaded or saved state. It rewrites the bound `PresetData`'s name and expression to the cached baseline values, replaces `currentElements` and `previewElements` with copies of the original element list, updates the text field through `view.setSequenceName`, and re-renders the flow view. This is used both by the Discard button and by callers that want to reset the form before switching presets.",
    "hasUnsavedChanges()": "Determines whether the user has modified the current preset since it was last loaded or saved. It compares the trimmed sequence name in the view against the cached `loadedSequenceName`, then builds an expression from `currentElements` and compares it to the original `loadedExpression`. Any difference in either field is treated as unsaved work, which informs auto-save behavior in `PresetManagerWindow`.",
    "onDragStart(...)": "Implementation of the `DragCallback` used by the sequence editor. At the start of a drag it snapshots the full ability sequence so cancellations can restore it exactly. For drags originating from the sequence, it resolves the element index corresponding to the dragged card and uses `ExpressionBuilder.removeAbilityAt` to create a preview list that omits that occurrence, logging before/after expressions. Palette-originated drags simply clone the current list.",
    "onDragEnd(AbilityItem, boolean)": "Implementation of the `DragCallback` that finalizes or cancels a drag-and-drop operation. It keeps track of whether the cursor left the panel and whether a valid drop highlight was shown. On commit inside a valid zone it uses `ExpressionBuilder.insertAbility` or `insertSequence` to apply the change; on a trash drop it permanently removes the previewed element; on cancel it restores the original snapshot. It then updates the backing `PresetData` expression and re-renders the flow view."
  },
  "ui.presetManager.detail.SequenceDetailPanel": {
    "SequenceDetailPanel(SequenceDetailService)": "Constructor for the main 'detail' view in the Preset Manager. It builds the name field, a compact clipboard-insert button, a Settings button placeholder, and Save/Discard buttons above a scrollable `AbilityFlowView`. The panel wires a `SequenceDetailPresenter` as its presenter and registers action listeners so Save and Discard delegate to presenter methods. It acts as the concrete `View` implementation that presenters and other panels interact with.",
    "startPaletteDrag(AbilityItem, JPanel, Point)": "Bridge method used by the `AbilityPalettePanel`. When the user begins dragging an ability from the palette, this method is called with the originating card and cursor position. It forwards the request to the presenter so the drag controller can treat palette-originated drops consistently with in-sequence drags, including previewing, inserting, and updating the underlying expression.",
    "discardChanges()": "Public façade for the Discard button. It simply delegates to `SequenceDetailPresenter.discardChanges`, which restores the sequence name and element list to the last loaded baseline and re-renders the flow view. `PresetManagerWindow` calls this when switching selections while auto-save is disabled so that half-edited sequences do not leak into other presets.",
    "startNewSequence(String, RotationConfig.PresetData)": "Convenience method used when adding or importing a new preset. It routes the provided ID and `PresetData` through the presenter's load path to populate the editor, then calls `highlightSequenceNameField` to focus and select the name text. This encourages the user to immediately give the new preset a meaningful title.",
    "setToastClient(ToastClient)": "Optional injection of a `ToastClient` that the panel will use for user feedback. When provided, the panel maps presenter messages and clipboard insert errors into success, warning, info, or error toasts; when absent, it falls back to standard `JOptionPane` dialogs or a simple system beep. This keeps the editor usable in both rich and minimal UI environments.",
    "clear()": "Clears the current sequence editor state. It calls through to the presenter, which resets all cached fields, empties the element lists, clears the sequence name, and re-renders the flow view with no cards. This is primarily used when the last preset is deleted from the master list.",
    "addSaveListener(SaveListener)": "Registers an observer that will be notified when the presenter completes a successful save. Listeners receive a `SaveResult` containing the final preset ID and data, allowing outer components like `PresetManagerWindow` to synchronize the master list model and selection without tightly coupling to the detail panel's internals.",
    "saveSequence()": "Imperative helper that triggers a save without going through the button's `ActionListener`. It simply forwards to the presenter's `saveSequence` method. `PresetManagerWindow` uses this during auto-save flows so that the same validation, persistence, and toast-reporting logic is reused regardless of whether the user clicked Save or switched presets.",
    "hasUnsavedChanges()": "Pass-through to `SequenceDetailPresenter.hasUnsavedChanges`. It lets the owner window ask the panel whether the currently edited preset diverges from the last loaded baseline, combining both name and expression differences. This signal is used to decide if auto-save should run when the user selects another preset.",
    "showSaveDialog(String, int)": "Implementation of the presenter's `View` interface for surfacing status messages. When a `ToastClient` is configured, it maps standard `JOptionPane` message types to success, warning, info, or error toasts without blocking the UI. If no client is available, it falls back to a modal `JOptionPane.showMessageDialog`, ensuring feedback is still visible in non-overlay environments."
  },
  "ui.presetManager.detail.ClipboardInsertItem": {
    "ClipboardInsertItem(String, String, ImageIcon, List<SequenceElement>, String)": "Constructor for a specialized `AbilityItem` that carries a parsed sequence rotation. It is used when dragging content from the clipboard insert button. Unlike a standard item which represents a single ability, this item holds a list of `SequenceElement`s and the original expression string.",
    "getElements()": "Returns the list of `SequenceElement` objects parsed from the clipboard content.",
    "getExpression()": "Returns the original raw string expression from the clipboard.",
    "isSingleAbility()": "Helper method to determine if the clipboard content consists of just a single ability (no separators). This allows the system to treat it like a standard ability drop if appropriate.",
    "isMultiStep()": "Helper method to determine if the clipboard content contains multiple steps (arrows), indicating a full rotation sequence."
  },
  "ui.presetManager.detail.AbilityGroupPanel": {
    "AbilityGroupPanel(Color)": "Constructor for a simple `JPanel` that acts as a visual container for a group of abilities that are linked by '+' (AND) or '/' (OR) operators. It uses a `FlowLayout` and sets a distinct background color and border to visually distinguish the group from standalone abilities in the `AbilityFlowView`."
  },
  "ui.presetManager.detail.AbilityCardFactory": {
    "createAbilityCard(AbilityItem)": "A factory method that creates a `JPanel` representing a single, draggable ability card in the sequence editor. It sets up the layout with an icon and a name label. Crucially, it attaches the `MouseAdapter` from the `AbilityDragController` to the card, making it draggable. It also stores the ability's key and element index as client properties for later retrieval during drag operations.",
    "createSeparatorLabel(SequenceElement)": "A factory method that creates a `JLabel` for displaying a separator (→, +, /) between ability cards in the `AbilityFlowView`. It styles the label to be visually distinct from the ability names."
  },
  "ui.presetManager.detail.AbilityFlowView": {
    "renderSequenceElements(List<SequenceElement>)": "The main rendering method for the sequence. It clears the panel and then iterates through the list of `SequenceElement`s. It intelligently groups consecutive abilities linked by '+' or '/' into a colored `AbilityGroupPanel` for better visual organization, while rendering standalone abilities and '→' separators directly. This method is what translates the flat list of elements into the structured visual representation.",
    "attachDragController(DragCallback)": "A setup method that connects this view to the `AbilityDragController`. It creates the controller, passing itself as the container and the `SequenceDetailPresenter` as the callback. This is a critical step in enabling the drag-and-drop functionality for this component.",
    "highlightDropZone(DropPreview)": "This method provides real-time visual feedback during a drag-and-drop operation. Based on the `DropPreview`, it highlights the target ability card with a color corresponding to the `DropZoneType` (e.g., green for AND, blue for OR). This shows the user exactly which card they are about to interact with. It's called on every mouse move during a drag.",
    "createPaletteDragListener(AbilityItem, JPanel)": "Creates a `MouseAdapter` that initiates a drag operation for a given ability item and card. This method delegates to the `AbilityDragController` to create the listener, enabling the new clipboard insert button (and other palette items) to trigger the standard drag-and-drop workflow."
  }
}
