{
  "infrastructure.hotkey.HotkeyBindingSource": {
    "loadBindings(AppSettings.HotkeySettings)": "This is the main method of the class, responsible for transforming the raw hotkey settings from `AppSettings` into a structured, usable format. It iterates through the user's configured bindings, uses `KeyChordParser` to convert string representations (e.g., 'CTRL', 'F1') into `KeyChord` objects, and maps them to their corresponding `HotkeyEvent`. It intelligently selects between user-defined and default global hotkeys. The final output is an unmodifiable `Map` used by the `HotkeyManager` to know which key combinations trigger which actions. It is called by `Main` during startup."
  },
  "infrastructure.hotkey.KeyChord": {
    "KeyChord(EnumSet<ModifierKey>, int)": "Constructor for this immutable value object, which represents a single hotkey combination. It takes an `EnumSet` of `ModifierKey`s (like CTRL, SHIFT) and a raw integer key code for the primary key. The class overrides `equals()` and `hashCode()`, making it suitable for use as a key in collections. This allows the `HotkeyManager` to perform efficient lookups to see if a pressed key combination matches a registered hotkey. It is instantiated by `KeyChordParser`."
  },
  "infrastructure.hotkey.HotkeyListener": {
    "onStartSequence()": "A default method within the `HotkeyListener` interface. It serves as a callback that is invoked by the `HotkeyManager` when the user presses the key combination registered for the 'start sequence' event. Classes that need to react to this event, such as `SequenceController`, implement this interface. The default implementation does nothing, making it optional for implementers.",
    "onRestartSequence()": "A default method in the `HotkeyListener` interface, acting as a callback for the 'restart sequence' hotkey event. When a user presses the corresponding key chord, the `HotkeyManager` calls this method on all registered listeners. The `SequenceController` implements this method to reset the active sequence. The default implementation is empty, so implementing classes only need to override the methods for events they care about."
  },
  "infrastructure.hotkey.KeyChordParser": {
    "parse(List<String>)": "This is the core logic of the class. It takes a list of string tokens, such as `['CTRL+SHIFT', 'F1']`, and attempts to convert them into a `KeyChord` object. It iterates through the tokens, identifies modifier keys (`ModifierKey.fromToken`) and the primary key (`KeyCodeLookup.getKeyCode`), and then constructs the `KeyChord`. This parser is used by `HotkeyBindingSource` to translate the human-readable configuration from `settings.json` into the structured objects required by the `HotkeyManager`."
  },
  "infrastructure.hotkey.HotkeyEvent": {
    "fromAction(String)": "A static factory method on the `HotkeyEvent` enum. It takes a raw string 'action' from the settings file (e.g., 'detection.start') and safely converts it into the corresponding enum member (`START_SEQUENCE`). This provides a controlled vocabulary for hotkey actions, decoupling the configuration from the core application logic and preventing errors from typos in the settings. It's used by `HotkeyBindingSource` during the binding process."
  },
  "infrastructure.hotkey.KeyCodeLookup": {
    "getKeyCode(String)": "A static utility method that converts a human-readable key name (e.g., 'F1', 'DELETE') into its corresponding integer key code from the `JNativeHook` library. It performs this lookup using a pre-computed, static map that is built at class-loading time by reflecting over the `NativeKeyEvent` class. This is essential for translating the string-based hotkey configuration into the raw key codes that `JNativeHook` provides.",
    "buildKeyCodes()": "A private static method that runs once when the class is loaded. It uses Java reflection to inspect all the `public static final int` fields in `JNativeHook`'s `NativeKeyEvent` class that start with 'VC_'. It extracts the key name and integer value for each, populating an unmodifiable map. This creates a comprehensive lookup table of all available key codes without having to manually define them, making the system adaptable to future `JNativeHook` updates."
  },
  "infrastructure.hotkey.ModifierKey": {
    "fromToken(String)": "A static factory method on the `ModifierKey` enum. It takes a string token from the hotkey configuration (e.g., 'CTRL', 'SHIFT') and converts it into the corresponding enum member. This allows the `KeyChordParser` to process the human-readable settings file. It handles common aliases, like 'CONTROL' for 'CTRL'.",
    "fromKeyCode(int)": "A static factory method on the `ModifierKey` enum. It takes a raw integer key code from a `JNativeHook` `NativeKeyEvent` and converts it into the corresponding enum member. This is used by the low-level `NativeHotkeyListener` to determine if a pressed key is a modifier like CTRL or SHIFT, which is crucial for tracking the currently active modifiers."
  },
  "infrastructure.hotkey.HotkeyManager": {
    "initialize()": "This static-synchronized method sets up the global, process-wide native keyboard hook using the `JNativeHook` library. It ensures this is done only once. It registers a single, static `NativeHotkeyListener` to receive all keyboard events. It also registers a JVM shutdown hook to ensure the native hook is properly unregistered, which is critical for preventing resource leaks and ensuring the application exits cleanly. It is called by `Main` at startup. Throws a `RuntimeException` if registration fails.",
    "addListener(HotkeyListener)": "A public method that allows other components, like `SequenceController`, to register for hotkey event notifications. It adds the provided `HotkeyListener` to an internal list. When a hotkey is detected by the low-level `NativeHotkeyListener`, the `HotkeyManager` will iterate through this list and notify each listener.",
    "notifyListeners(HotkeyEvent)": "A private method that is called by the internal `NativeHotkeyListener` when a valid, registered hotkey combination is detected. It iterates through the list of registered `HotkeyListener`s and calls the appropriate method (e.g., `onStartSequence`) based on the `HotkeyEvent`. This decouples the low-level native hook from the high-level application logic.",
    "NativeHotkeyListener.nativeKeyPressed(NativeKeyEvent)": "The core method of the private inner listener class. This method is called by `JNativeHook` for every key press event in the entire operating system. It first checks if the pressed key is a modifier and updates its internal state. If it's a regular key, it creates a `KeyChord` representing the current state and checks if this chord is registered for any `HotkeyEvent`. If a match is found, it triggers the `notifyListeners` method in the parent `HotkeyManager`.",
    "NativeHotkeyListener.nativeKeyReleased(NativeKeyEvent)": "A callback from `JNativeHook` that is invoked whenever any key is released. Its sole responsibility is to check if the released key was a modifier key (CTRL, SHIFT, etc.). If so, it removes that modifier from its internal `activeModifiers` set. This ensures that the state of pressed modifiers is always accurate when the next key press event occurs."
  }
}