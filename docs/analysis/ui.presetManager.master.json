{
  "ui.presetManager.PresetManagerAction": {
    "execute()": "This method implements the `MenuAction` interface for the 'Preset Manager' menu item. When called, it dispatches work to the Swing Event Dispatch Thread via `SwingUtilities.invokeLater`, uses `PresetManagerWindowBuilder` to construct all Preset Manager dependencies, and caches the resulting `PresetManagerWindow` so only a single instance exists. If a window is already visible it simply brings it to the front and requests focus. When the builder fails and returns null, it logs an error instead of throwing, ensuring failures are reported cleanly in logs."
  },
  "ui.presetManager.masterRotations.SelectedSequenceIndicator": {
    "forSettings(AppSettings)": "A static factory method that creates an instance of `SelectedSequenceIndicator` bound to the application's `AppSettings`. It provides a `Supplier` that knows how to retrieve the currently selected rotation ID from the settings. This is the primary way this class is instantiated, decoupling the indicator from the specifics of the configuration structure.",
    "iconFor(String)": "This is the main public method used by the `SequenceListCellRenderer`. It takes a sequence ID and checks if it matches the currently selected ID (obtained via the `selectedIdSupplier`). If it matches, it returns the visual 'selected' icon; otherwise, it returns null. This allows the `JList` to display an indicator next to only the active rotation.",
    "createDefaultIcon()": "A private static method that programmatically creates the 'selected' icon, which is a green circle with a white checkmark. It uses `BufferedImage` and `Graphics2D` to draw the icon at runtime. This avoids the need to bundle a separate image file and allows for easy modification of the icon's appearance."
  },
  "ui.presetManager.masterRotations.SequenceListModel": {
    "loadFromConfig(RotationConfig)": "Populates the list model with data from the `RotationConfig`. It clears any existing data and then iterates through the `presets` map from the configuration, creating a `SequenceEntry` for each one. It correctly fires `fireIntervalRemoved` and `fireIntervalAdded` events to notify the listening `JList` that the data has changed, causing it to repaint.",
    "upsert(String, PresetData)": "Updates or inserts a sequence entry. It first searches for an existing entry with the given ID. If found, it updates the `PresetData` and fires a `fireContentsChanged` event to notify the `JList` of the change. If not found, it adds a new `SequenceEntry` to the end of the list and fires an `fireIntervalAdded` event. This is the primary method for updating the list when a preset is saved."
  },
  "ui.presetManager.masterRotations.SequenceMasterPanel": {
    "SequenceMasterPanel(...)": "Constructor for the master rotation list panel. It binds a `SequenceListModel` to a single-selection `JList` with a renderer that paints the selected-rotation glyph, wires selection handlers, and creates Add/Delete/Import/Export buttons (loading a trash icon with a text fallback). It now composes a `RunControlPanel` and `SequenceRunPresenter`, wiring button listeners to presenter callbacks and subscribing to `SequenceRunService` state/progress updates so run controls and status text stay in sync. The run presenter is attached as this panel's view so it can drive button labels, highlights, and status messaging while listener collections expose selection/add/delete/import events to the surrounding window.",
    "addSelectionListener(Consumer<SequenceEntry>)": "A public method that allows other components, specifically the `PresetManagerWindow`, to register a callback for when the user selects a different sequence in the `JList`. This is the core of the master-detail pattern, enabling the detail panel to be updated when the selection changes.",
    "importFromClipboard()": "The action handler for the 'Import' button. It reads text from the system clipboard using `getClipboardContent`, short-circuits when the clipboard is empty or cannot be read, and validates non-empty content with the injected `expressionValidator`. For valid expressions it forwards the string to all registered import listeners so the detail panel can open or create a preset. For invalid or unreadable content it uses the injected `NotificationService` to surface friendly error or info messages instead of blocking the UI with modal dialogs.",
    "SequenceListCellRenderer.getListCellRendererComponent(...)": "The core method of the private inner `JList` renderer. It's called for every item in the list to determine how it should be displayed. It sets the text of the label to the preset's name, paints the selected-rotation glyph from `SelectedSequenceIndicator` in a dedicated column, and mirrors the list's selection and focus colors. It also updates the row tooltip to indicate which entry is currently the active rotation stored in settings.",
    "setNotificationService(NotificationService)": "Optional injection point for a `NotificationService`. The panel caches it for clipboard/read failures, export feedback, and other UI toasts, and forwards the same instance into the `SequenceRunPresenter` so run-control interactions use consistent messaging. Without a notifier the component still runs but falls back to beeps or silent state changes for some actions.",
    "setStartButtonState(String, boolean, boolean)": "Implements `SequenceRunView` by delegating to the `RunControlPanel` to change the Start/Arm button label, enabled state, and highlight colors based on the presenter’s instructions. Called on the EDT to keep the button in sync with controller state.",
    "setPauseButtonState(boolean, boolean)": "Implements `SequenceRunView` by toggling the Pause button’s enabled state and highlight styling through the `RunControlPanel`, allowing the presenter to mark PAUSED as the active action without directly touching Swing components.",
    "setRestartButtonEnabled(boolean)": "Implements `SequenceRunView` by switching the Restart button’s enabled flag via the `RunControlPanel`. The presenter uses this to keep restart available whenever a run service exists.",
    "setStatusText(String)": "Implements `SequenceRunView` by passing the presenter’s computed status text down to the `RunControlPanel` label so users see detection state, current step, and watched abilities updates without the presenter manipulating UI widgets directly."
  },
  "ui.presetManager.masterRotations.SequenceRunPresenter": {
    "SequenceRunPresenter(SequenceRunService, NotificationService)": "Presenter that owns run-control state and messaging. It captures the injected `SequenceRunService` and notifier, immediately snapshots controller state, progress, and detection-running flags when a service exists, and prepares to drive a bound `SequenceRunView` without the view needing direct access to the service.",
    "attachView(SequenceRunView)": "Binds the UI-facing view and immediately calls `applyView` so the buttons and status text reflect whatever state and progress snapshot the presenter currently holds, ensuring the controls are correct even before the user interacts.",
    "refreshFromService()": "Pulls the latest controller state, progress snapshot, and detection-running flag from `SequenceRunService` when available, or resets to READY with no progress when the service is absent. It then reapplies the view to synchronize button labels and status text with reality.",
    "onStartRequested()": "Handler for the Start/Arm button. If no run service is wired it emits an error toast and aborts. When available it checks whether the prior run completed and calls `prepareReadyState()` to reset, requests `start()` on the service, refreshes snapshots, and shows an informational toast indicating the start request was issued.",
    "onPauseRequested()": "Pause button handler. It guards against a missing run service with an error toast, otherwise delegates to `SequenceRunService.pause()` to stop detection and reset the active sequence, refreshes cached state/progress, and surfaces a toast confirming detection has been paused.",
    "onRestartRequested()": "Handler for the Restart control. It requires a run service; on success it calls `restart()` to re-arm the controller while keeping detection running, refreshes the presenter’s snapshot, and announces the restart via a success toast.",
    "onStateChanged(SequenceController.State, SequenceController.State)": "Listener invoked when the `SequenceRunService` reports controller state transitions. It updates the cached state, re-reads whether detection is running, and reapplies the view so button highlights and status text track changes triggered outside the UI.",
    "onProgressChanged(SequenceManager.SequenceProgress)": "Listener for progress updates from the run service. It caches the latest progress object, refreshes the detection-running flag, and reapplies the view so the status line and ability list reflect the current step even while a run is active.",
    "applyView()": "Central routine that pushes cached state and progress into the bound view on the EDT. It derives the Start button label (Arm/Armed/Running/Start), decides which buttons should be highlighted or enabled, and composes a status string that notes selection, completion, detection state, current step index, and the abilities being watched.",
    "buildStatusText(State, SequenceProgress, boolean)": "Formats the status line shown above the run controls. It handles empty selections, completed runs, paused states, armed waiting with the current abilities, running with step counters, and ready state both with and without detection running, falling back to the enum name for any unexpected controller state."
  },
  "ui.presetManager.masterRotations.RunControlPanel": {
    "RunControlPanel()": "Builds the run control UI with a status label above a Start/Arm, Pause, and Restart button row. It caches default and highlight colors (from `UiColorPalette`) so the presenter can emphasize the active action, and initializes labels with a ready status.",
    "addStartListener(ActionListener)": "Registers a listener on the Start/Arm button when provided, allowing external presenters to react to user clicks without exposing the Swing component.",
    "addPauseListener(ActionListener)": "Attaches a listener to the Pause button if non-null so the presenter can respond to pause requests.",
    "addRestartListener(ActionListener)": "Hooks a listener to the Restart button when supplied, enabling restart actions to be driven externally.",
    "setStartButtonState(String, boolean, boolean)": "Sets the Start/Arm button label and enabled state, and applies highlight colors when requested so the UI reflects whether READY/ARMED is the active path.",
    "setPauseButtonState(boolean, boolean)": "Enables/disables the Pause button and toggles its highlight color when it represents the active state (e.g., PAUSED), keeping visual feedback consistent.",
    "setRestartButtonEnabled(boolean)": "Controls the Restart button’s enabled flag and ensures it stays visible so users can rerun completed rotations.",
    "setStatusText(String)": "Updates the status label text, used by the presenter to display controller state, detection status, and current step information."
  },
  "ui.presetManager.PresetManagerWindow": {
    "PresetManagerWindow(ConfigManager, SequenceListModel, AbilityIconLoader, SequenceDetailService, SelectedSequenceIndicator, SequenceRunService)": "Constructor for the main `JFrame` of the Preset Manager. Instead of constructing its own dependencies, it now receives a pre-built `SequenceListModel`, `AbilityIconLoader`, `SequenceDetailService`, `SelectedSequenceIndicator`, and a `SequenceRunService` from `PresetManagerWindowBuilder`, keeping this class focused on layout and orchestration. It initializes the frame shell, creates a `ToastManager` and `NotificationService`, and then calls `initializeComponents` to build the master list, detail editor, and ability palette, wiring the master panel to the run service so its Start/Pause/Restart controls drive detection. On success it lays out the nested `JSplitPane`s, wires event handlers, loads sequences, and shows the window; on failure it logs an error and skips layout and wiring.",
    "wireEventHandlers()": "A private method that connects the master, detail, and configuration layers. It registers listeners on the master panel for add, delete, and clipboard-import actions, supplies a robust expression validator for imports, and subscribes to selection changes. When the user switches presets it either auto-saves the current one (only when auto-save is enabled and there are unsaved changes) or explicitly discards edits. It also registers a save listener on the detail panel that updates the list model, recenters selection for newly created presets, and shows a success toast.",
    "handleDeleteSequence(SequenceEntry)": "The listener for the delete button. It validates that a preset is selected, prompts the user with a warning dialog, and on confirmation removes the preset from `RotationConfig` and persists the change via `configManager.saveRotations()`. Afterwards it reloads the list model, tries to keep or sensibly reassign the active selection, clears the detail panel when nothing remains, and reports both success and failure paths through structured logging and toast messages.",
    "updateActiveRotation(String)": "This method is called whenever the user selects a sequence in the master list. It lazily initializes the `RotationSettings` section of `AppSettings` if needed, compares the new ID with the current one, and only writes to disk when the active selection actually changes. On change it updates `selectedId`, calls `configManager.saveSettings()` with error handling that logs and toasts failures, and finally asks the master panel to refresh its list so the selected-rotation indicator stays in sync."
  }
}
