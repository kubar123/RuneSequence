{
  "ui.presetManager.PresetManagerAction": {
    "execute()": "This method implements the `MenuAction` interface for the 'Preset Manager' menu item. When called, it dispatches work to the Swing Event Dispatch Thread via `SwingUtilities.invokeLater`, uses `PresetManagerWindowBuilder` to construct all Preset Manager dependencies, and caches the resulting `PresetManagerWindow` so only a single instance exists. If a window is already visible it simply brings it to the front and requests focus. When the builder fails and returns null, it logs an error instead of throwing, ensuring failures are reported cleanly in logs."
  },
  "ui.presetManager.masterRotations.SelectedSequenceIndicator": {
    "forSettings(AppSettings)": "A static factory method that creates an instance of `SelectedSequenceIndicator` bound to the application's `AppSettings`. It provides a `Supplier` that knows how to retrieve the currently selected rotation ID from the settings. This is the primary way this class is instantiated, decoupling the indicator from the specifics of the configuration structure.",
    "iconFor(String)": "This is the main public method used by the `SequenceListCellRenderer`. It takes a sequence ID and checks if it matches the currently selected ID (obtained via the `selectedIdSupplier`). If it matches, it returns the visual 'selected' icon; otherwise, it returns null. This allows the `JList` to display an indicator next to only the active rotation.",
    "createDefaultIcon()": "A private static method that programmatically creates the 'selected' icon, which is a green circle with a white checkmark. It uses `BufferedImage` and `Graphics2D` to draw the icon at runtime. This avoids the need to bundle a separate image file and allows for easy modification of the icon's appearance."
  },
  "ui.presetManager.masterRotations.SequenceListModel": {
    "loadFromConfig(RotationConfig)": "Populates the list model with data from the `RotationConfig`. It clears any existing data and then iterates through the `presets` map from the configuration, creating a `SequenceEntry` for each one. It correctly fires `fireIntervalRemoved` and `fireIntervalAdded` events to notify the listening `JList` that the data has changed, causing it to repaint.",
    "upsert(String, PresetData)": "Updates or inserts a sequence entry. It first searches for an existing entry with the given ID. If found, it updates the `PresetData` and fires a `fireContentsChanged` event to notify the `JList` of the change. If not found, it adds a new `SequenceEntry` to the end of the list and fires an `fireIntervalAdded` event. This is the primary method for updating the list when a preset is saved."
  },
  "ui.presetManager.masterRotations.SequenceMasterPanel": {
    "SequenceMasterPanel(...)": "Constructor for the 'master' view in the Preset Manager, which displays the list of all available sequences. It wires a `SequenceListModel` into a single-selection `JList`, configures a custom `SequenceListCellRenderer` that shows the selected-rotation indicator, and creates Add/Delete/Import/Export buttons. It also builds Start/Pause/Restart controls and a state label, which drive a `SequenceRunService` when one is provided, and subscribes to controller state changes so button highlights and the label stay in sync. Listener collections allow `PresetManagerWindow` to react to selection, add, delete, and import events without depending on concrete UI widgets.",
    "addSelectionListener(Consumer<SequenceEntry>)": "A public method that allows other components, specifically the `PresetManagerWindow`, to register a callback for when the user selects a different sequence in the `JList`. This is the core of the master-detail pattern, enabling the detail panel to be updated when the selection changes.",
    "importFromClipboard()": "The action handler for the 'Import' button. It reads text from the system clipboard using `getClipboardContent`, short-circuits when the clipboard is empty or cannot be read, and validates non-empty content with the injected `expressionValidator`. For valid expressions it forwards the string to all registered import listeners so the detail panel can open or create a preset. For invalid or unreadable content it uses the injected `NotificationService` to surface friendly error or info messages instead of blocking the UI with modal dialogs.",
    "handleStart()": "Private handler for the Start button in the master panel. It first checks whether a `SequenceRunService` has been wired; if not, it reports that the action is unavailable through the `NotificationService` and returns. When the service is available it calls `sequenceRunService.start()` to ensure detection is running and arm the controller, refreshes the state indicator using the controller's current state, and shows a success notification so the user knows a start request has been issued.",
    "handlePause()": "Private handler for the Pause button. If no `SequenceRunService` is present it reports that pausing is unavailable via the `NotificationService` and exits. Otherwise it delegates to `sequenceRunService.pause()`, which sets the controller state to PAUSED, resets the active sequence, and stops detection. After pausing it updates the visual state indicator and shows an informational notification to confirm that detection has been paused.",
    "handleRestart()": "Private handler for the Restart button. It guards against a missing `SequenceRunService` by showing an error notification and returning. When the service is available it calls `sequenceRunService.restart()` to re-arm the controller and restart the active sequence while keeping detection running. It then refreshes the state indicator from the controller's current state and displays a success notification, giving users a single-click way to restart without manually toggling hotkeys.",
    "updateStateIndicator(State)": "A helper that keeps the Start and Pause buttons, plus the state label, visually synchronized with the `SequenceController`'s state. It runs updates on the Swing event dispatch thread, switching button background and foreground colors using `UiColorPalette` values so the active action is highlighted (Start for non-paused states, Pause for PAUSED) and updating the label text to show the current state enum. It is invoked in response to controller state change events and directly after start, pause, or restart actions.",
    "SequenceListCellRenderer.getListCellRendererComponent(...)": "The core method of the private inner `JList` renderer. It's called for every item in the list to determine how it should be displayed. It sets the text of the label to the preset's name, paints the selected-rotation glyph from `SelectedSequenceIndicator` in a dedicated column, and mirrors the list's selection and focus colors. It also updates the row tooltip to indicate which entry is currently the active rotation stored in settings.",
    "setNotificationService(NotificationService)": "Optional injection point for a `NotificationService`. The panel stores the reference and uses it to report clipboard import failures, empty selections, export success or errors, and run-control problems such as a missing `SequenceRunService`, all via non-blocking toasts. When no service is supplied it still performs its core actions but loses rich feedback, falling back to simple audible beeps for some operations, which keeps the component usable in headless or test scenarios."
  },
  "ui.presetManager.PresetManagerWindow": {
    "PresetManagerWindow(ConfigManager, SequenceListModel, AbilityIconLoader, SequenceDetailService, SelectedSequenceIndicator, SequenceRunService)": "Constructor for the main `JFrame` of the Preset Manager. Instead of constructing its own dependencies, it now receives a pre-built `SequenceListModel`, `AbilityIconLoader`, `SequenceDetailService`, `SelectedSequenceIndicator`, and a `SequenceRunService` from `PresetManagerWindowBuilder`, keeping this class focused on layout and orchestration. It initializes the frame shell, creates a `ToastManager` and `NotificationService`, and then calls `initializeComponents` to build the master list, detail editor, and ability palette, wiring the master panel to the run service so its Start/Pause/Restart controls drive detection. On success it lays out the nested `JSplitPane`s, wires event handlers, loads sequences, and shows the window; on failure it logs an error and skips layout and wiring.",
    "wireEventHandlers()": "A private method that connects the master, detail, and configuration layers. It registers listeners on the master panel for add, delete, and clipboard-import actions, supplies a robust expression validator for imports, and subscribes to selection changes. When the user switches presets it either auto-saves the current one (only when auto-save is enabled and there are unsaved changes) or explicitly discards edits. It also registers a save listener on the detail panel that updates the list model, recenters selection for newly created presets, and shows a success toast.",
    "handleDeleteSequence(SequenceEntry)": "The listener for the delete button. It validates that a preset is selected, prompts the user with a warning dialog, and on confirmation removes the preset from `RotationConfig` and persists the change via `configManager.saveRotations()`. Afterwards it reloads the list model, tries to keep or sensibly reassign the active selection, clears the detail panel when nothing remains, and reports both success and failure paths through structured logging and toast messages.",
    "updateActiveRotation(String)": "This method is called whenever the user selects a sequence in the master list. It lazily initializes the `RotationSettings` section of `AppSettings` if needed, compares the new ID with the current one, and only writes to disk when the active selection actually changes. On change it updates `selectedId`, calls `configManager.saveSettings()` with error handling that logs and toasts failures, and finally asks the master panel to refresh its list so the selected-rotation indicator stays in sync."
  }
}
