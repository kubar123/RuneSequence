{
  "core.sequence.parser.Tokenizer": {
    "tokenize(String)": "The main public method of the `Tokenizer`. It takes a raw sequence expression string as input and breaks it down into a `List` of `Token` objects. The process involves several stages: normalizing arrow symbols, adding padding around operators to ensure clean splitting, and then iterating through the parts to intelligently merge multi-word ability names while separating out operators and parentheses. This token stream is the direct input for the `SequenceParser`. It is a critical first step in understanding the user's intended ability rotation."
  },
  "core.sequence.parser.SequenceParser": {
    "parse(String)": "The primary static entry point for the parser. It takes a raw expression string, creates a `Tokenizer` to convert it into a list of `Token`s, and then instantiates itself to begin the parsing process. It calls `parseExpression` to build the Abstract Syntax Tree (AST) and then ensures the entire token stream was consumed to catch syntax errors. The final, validated `SequenceDefinition` (the root of the AST) is returned. This is called by `Main` to process all configured rotations at startup.",
    "parseExpression()": "This method implements the top-level rule of the grammar (`Expression := Step ('→' Step)*`). It parses one or more `Step`s, separated by the '→' operator. It calls `parseStep` to handle the parsing of each individual step. This recursive descent structure is central to the parser's design.",
    "parseStep()": "Implements the `Step` rule of the grammar (`Step := Term ('+' Term)*`). It parses one or more `Term`s that are to be executed simultaneously, separated by the '+' operator. It calls `parseTerm` to handle each component.",
    "parseTerm()": "Implements the `Term` rule of the grammar (`Term := Alternative ('/' Alternative)*`). It parses one or more `Alternative`s, which represent abilities that can be used interchangeably, separated by the '/' operator. It calls `parseAlternative` for each.",
    "parseAlternative()": "The lowest level of the recursive descent parser, implementing the `Alternative` rule (`Alternative := Ability | '(' Expression ')'`). It checks for a left parenthesis to handle nested sub-expressions (by recursively calling `parseExpression`) or consumes an `Ability` token for a simple ability name. This is where the tree structure of the AST is actually built."
  },
  "core.sequence.parser.Token": {
    "Token.Ability(String)": "A record implementing the `Token` sealed interface, representing an ability name. It encapsulates the string name of the ability. The constructor includes validation to ensure the name is not null or blank. These tokens are created by the `Tokenizer` when it identifies a sequence of characters that is not an operator or parenthesis.",
    "Token.Operator(String)": "A record that represents an operator token (→, +, /). It includes constructor validation to ensure that only valid symbols can be used to create an operator token. Used by the `Tokenizer` and consumed by the `SequenceParser` to structure the AST.",
    "Token.LeftParen()": "A record representing a left parenthesis token '('. Used by the `Tokenizer` and `SequenceParser` to handle nested sub-expressions.",
    "Token.RightParen()": "A record representing a right parenthesis token ')'. Used by the `Tokenizer` and `SequenceParser` to close nested sub-expressions."
  },
  "core.sequence.parser.TooltipMarkupParser": {
    "parse(String)": "Parses tooltip annotations from a raw expression string. Tooltip segments use the syntax `(message)` adjacent to abilities. This method strips them from the expression before handing the cleaned string to the core `SequenceParser`. It returns a `ParseResult` containing the cleaned expression and a list of `TooltipPlacement` instructions that map the original tooltip messages to their correct structural indices, allowing them to be re-attached later.",
    "insertTooltips(List<T>, List<TooltipPlacement>, TooltipFactory<T>)": "Re-injects tooltip elements into a list of base elements (e.g., visual UI elements) based on the placements computed during parsing. It iterates through the placements and inserts new tooltip objects created by the provided factory at the correct indices, handling offset adjustments as the list grows.",
    "mapPlacements(String, List<TooltipToken>)": "A private helper that correlates the extracted tooltip tokens with their structural position in the expression. It tokenizes the placeholder-laden expression to determine which ability step or operator each tooltip belongs to, effectively translating raw string positions into logical structural indices."
  },
  "core.sequence.parser.TooltipGrammar": {
    "isValidTooltipMessage(String)": "Validates whether a given string is acceptable as a tooltip message. It ensures the message is not null and does not contain any reserved structural operators (arrow, plus, slash) that would confuse the parser.",
    "escapeTooltipText(String)": "Escapes special characters within a tooltip message, specifically parentheses `(` and `)`, so they can be safely embedded in the expression string without breaking the parser's grouping logic."
  },
  "core.sequence.parser.TooltipStructure": {
    "linearize(SequenceDefinition)": "Flattens the hierarchical `SequenceDefinition` (AST) into a linear list of `StructuralElement`s. This linear view is essential for consistently mapping tooltip placements to specific steps or operators, ensuring that both the runtime schedule builder and the UI visual service agree on where tooltips should appear."
  }
}
