{
  "ui.presetManager.service.SequenceVisualService": {
    "parseToVisualElements(String)": "The main public method that serves as the primary entry point for this service. It takes a raw sequence expression string, orchestrates the full conversion pipeline by first calling `SequenceParser.parse` to get the AST, and then calling `convertDefinitionToElements` to transform the AST into a flat list of `SequenceElement` objects suitable for UI rendering. This is used by the `PresetManagerWindow` to display the ability sequence.",
    "convertDefinitionToElements(SequenceDefinition)": "A private recursive method that traverses the `SequenceDefinition` AST (the model) and converts it into a flat list of `SequenceElement` objects (the view model). It iterates through each `Step`, `Term`, and `Alternative`, adding `SequenceElement.ability()` for tokens and appropriate separator elements (`.plus()`, `.slash()`, `.arrow()`) between them. This is the core logic that translates the abstract tree into a linear, visual representation."
  },
  "ui.presetManager.service.ExpressionBuilder": {
    "buildExpression(List<SequenceElement>)": "This method performs the reverse operation of the `SequenceVisualService`. It takes a list of `SequenceElement` objects from the UI and concatenates their string values to reconstruct the raw sequence expression string. This is used to save the user's changes back to the `rotations.json` configuration file.",
    "removeAbilityAt(List<SequenceElement>, int)": "A key business logic method for editing a sequence. It removes an ability element at a given index from the list. Critically, after removing the ability, it calls `cleanupAfterRemoval` to normalize the surrounding separators. For example, removing 'B' from 'A + B + C' results in 'A + C', not 'A + + C'. This ensures the resulting sequence remains syntactically valid.",
    "insertAbility(List<SequenceElement>, String, int, DropZoneType, DropSide)": "This is the most complex method, handling the logic for adding a new ability to the sequence based on a drag-and-drop operation. It uses the `DropZoneType` (AND, OR, NEXT) and `DropSide` (LEFT, RIGHT) to determine where and how to insert the new ability and its corresponding separators. It correctly handles inserting into existing groups, creating new groups, or splitting existing groups, ensuring the resulting sequence is always well-formed.",
    "insertSequence(List<SequenceElement>, List<SequenceElement>, int, DropZoneType, DropSide)": "Inserts an entire sequence of elements (e.g., from a clipboard paste) into the current sequence at the specified location. It handles complex insertion logic, including splitting existing groups if inserting with `NEXT` zone type, and normalizing separators to ensure the resulting sequence is valid. It allows for bulk insertion of multi-step rotations.",
    "analyzeGroup(List<SequenceElement>, int)": "A private helper method used by the insertion and removal logic. Given a list of elements and the index of an ability, it scans backwards and forwards from that index to identify if the ability is part of a contiguous group (connected by '+' or '/'). It returns a `GroupInfo` object containing the group's type and its start and end indices. This is essential for making intelligent decisions about how to modify groups during editing."
  }
}