{
  "infrastructure.config.AppSettings": {
    "RegionSettings.toRectangle()": "A convenience method within the nested `RegionSettings` class. It converts the stored x, y, width, and height properties into a `java.awt.Rectangle` object. This is used by the `ScreenCapture` service to define the area of the screen to be captured for analysis. It has no dependencies and is called by `ScreenCapture`.",
    "AppSettings()": "The default constructor for the main settings container. It initializes the default values for all nested setting objects (`RegionSettings`, `DetectionSettings`, etc.). This class is primarily a POJO designed for deserialization from `settings.json` by the Jackson library. Its structure mirrors the JSON file's schema, with nested classes for organization. It is instantiated by `ConfigManager`.",
    "RotationSettings.isAutoSaveOnSwitch()": "Accessor on the nested `RotationSettings` class that controls whether the preset editor should automatically save changes when the user switches presets. When `true`, `PresetManagerWindow` will call into the detail panel to persist any unsaved edits before loading another sequence; when `false`, it discards pending changes instead. The property is exposed in the Settings UI and defaults to `false` so existing users do not suddenly change workflow without opting in."
  },
  "infrastructure.config.ScalingConverter": {
    "getScaling(int)": "A static utility method that converts a UI scaling percentage (e.g., 100, 150) into a concrete icon size in pixels (e.g., 30, 45). It performs a lookup in a static, pre-populated `HashMap`. This is a critical function used by `TemplateCache` and `ConfigManager` to determine which subfolder of pre-scaled images should be loaded, ensuring high-quality icons are used for detection. If no mapping exists, it returns null.",
    "getAllSizes()": "A static utility method that returns a sorted array of all supported icon sizes in pixels (e.g., 30, 34, 36). It retrieves these from the values of the internal static map. This method is called by `ConfigManager` during the one-time image pre-processing step to determine which scaled versions of the ability icons need to be generated and saved to disk.",
    "getAllScalePercentages()": "A static utility method that returns the `Set` of all supported UI scaling percentages (e.g., 100, 110, 120). This can be used to populate a dropdown in a settings UI, allowing the user to select a valid scaling option that corresponds to a pre-generated set of icons."
  },
  "infrastructure.config.AbilityConfig": {
    "setAbility(String, AbilityData)": "A method annotated with `@JsonAnySetter`, used by the Jackson deserialization library. For every top-level key-value pair in the `abilities.json` file, Jackson calls this method. The key (the ability's unique name) and the deserialized `AbilityData` object are passed as arguments, allowing for the dynamic population of the internal `abilities` map. This is essential for loading the configuration from disk.",
    "getAbility(String)": "A public convenience method that provides direct, type-safe access to the configuration data for a single ability. It takes the ability's name as a key and returns the corresponding `AbilityData` object from the internal map. This is used extensively by `SequenceManager` and `TemplateDetector` to retrieve properties like whether an ability triggers the global cooldown or has a custom detection threshold.",
    "AbilityConfig()": "The default constructor for the `AbilityConfig` class. It initializes an empty `HashMap` to store the configuration data for each ability. As this class is primarily a data holder for Jackson deserialization from `abilities.json`, this parameterless constructor is required for the library to be able to instantiate the object before populating its fields.",
    "AbilityData()": "The default constructor for the nested static `AbilityData` class. This class is a POJO representing the configuration for a single ability, such as its cooldown or type. It initializes with default values, for instance, `triggersGcd` is set to `true`. This parameterless constructor is essential for Jackson to be able to deserialize the JSON data for each ability into a corresponding Java object."
  },
  "infrastructure.config.RotationConfig": {
    "RotationConfig()": "The default constructor for the `RotationConfig` class. It initializes an empty `HashMap` to store the preset rotation data. This class is a POJO used by the Jackson library to deserialize the `rotations.json` file. It is instantiated by the `ConfigManager` when loading configurations.",
    "PresetData()": "The default constructor for the nested static `PresetData` class. This is a simple data container for a single rotation preset, holding its user-friendly name and the raw sequence expression string. This parameterless constructor is required by the Jackson library to instantiate the object before populating its fields from the `rotations.json` file."
  },
  "infrastructure.config.ConfigManager": {
    "ConfigManager()": "Constructor for the `ConfigManager`. It initializes the paths for all configuration files (`settings.json`, `rotations.json`, etc.) based on the operating system's standard application data location, determined by the static `getAppDataPath()` method. It also creates and configures a reusable Jackson `ObjectMapper` instance, which is used for all subsequent JSON serialization and deserialization tasks. It is instantiated by `Main` at startup.",
    "initialize()": "The main initialization method for the `ConfigManager`. It orchestrates the entire setup process: it ensures the main configuration directory exists, and then calls a series of `loadOrCreate...` methods to either load existing JSON configuration files or, if they are missing, extract and write the default versions from the application's resources using `AssetExtractor`. It also triggers the initial processing of ability images. Called by `Main`, this method is critical for application startup.",
    "checkOrCreateAbilities()": "A private helper method called during initialization that specifically handles the 'Abilities' asset directory. If the directory does not exist, it calls `AssetExtractor` to copy the default ability icons from the application's embedded resources to the user's configuration folder. After extraction, it calls `processAbilityImages` to generate pre-scaled versions of these icons for performance.",
    "processAbilityImages(Path)": "This method creates an instance of `OpenCvImageProcessor` and uses it to pre-process the source ability icons. It gets a list of all required icon sizes from `ScalingConverter` and instructs the processor to generate resized and masked versions of each ability icon for every required size. This pre-processing is a key performance optimization, avoiding the need for real-time resizing during detection. It is called once during initial setup.",
    "loadOrCreateSettings()": "Manages the `settings.json` file. It checks if the file exists; if so, it loads it into the `settings` object. If not, it calls a helper to load the default configuration from embedded resources and then `saveSettings` to write it to disk. This 'load or create' pattern ensures the application always has a valid configuration to work with.",
    "needsAbilitiesMigration()": "A private predicate method that checks if the loaded `abilities.json` data is from an older version of the application. It does this by sampling a few ability entries and checking for the absence of newly added fields (like `commonName`). This is a simple but effective mechanism for triggering a data migration path to ensure the application has the most up-to-date schema without losing user data entirely.",
    "resolveAbilityIconFolder(int)": "A smart resolver for finding the best pre-scaled icon folder. It first looks for a subfolder that exactly matches the requested `iconSize`. If not found, it searches for all numeric subfolder names, finds the one numerically closest to the requested size, and returns that path. This provides a robust fallback if the exact size isn't available, preventing errors when the user selects an unusual UI scale.",
    "getAppDataPath()": "A static utility method that determines the correct path for application data based on the operating system. It handles the different conventions for Windows (`%APPDATA%`), macOS (`~/Library/Application Support`), and Linux (`~/.config` or `$XDG_CONFIG_HOME`), providing a cross-platform solution for storing all user configuration and assets."
  },
  "infrastructure.config.AbilityCategoryConfig": {
    "addCategory(String, List<String>)": "A method annotated with `@JsonAnySetter`, which is a special Jackson instruction. During deserialization of `ability_categories.json`, this method is called for any top-level key in the JSON object. It allows the parser to dynamically populate the `categories` map from a simple JSON structure like `{\"Melee\": [...], \"Magic\": [...]}` without needing to explicitly define every category as a field in the class. This makes the configuration flexible.",
    "AbilityCategoryConfig()": "The default constructor for the `AbilityCategoryConfig` class. This class is designed as a POJO for deserialization by the Jackson library. It initializes an empty `HashMap` to store the categories. This constructor is used by Jackson when creating an instance from the `ability_categories.json` file. It is instantiated by `ConfigManager`."
  },
  "infrastructure.config.AssetExtractor": {
    "extractDefaultAssets(String, Path)": "The main public method for extracting a resource directory (like default configs or images) from within the application's JAR file to an external target directory on the user's filesystem. It determines if the application is running from a JAR or the local file system and delegates to the appropriate helper (`extractFromJar` or `extractFromFileSystem`). This is crucial for making default assets available to the user for customization and is called by `ConfigManager` on first run.",
    "extractFromJar(URI, String, Path)": "A private helper method that handles the complex logic for extracting resources from within a JAR file. It creates a temporary `FileSystem` to access the JAR's contents, then walks the file tree starting from the specified `resourceRoot`. For each file and directory, it recursively recreates the structure in the `targetDir`, copying files over. This is necessary because resources inside a JAR are not directly accessible as standard files.",
    "extractFromFileSystem(Path, Path)": "A private helper method for the simpler case where the application is not running from a JAR (e.g., during development). It directly walks the source directory tree on the file system and copies its contents to the target directory. This method ensures that the asset extraction feature works correctly in both development and production environments."
  }
}
