{
  "ui.overlay.OverlayRenderer": {
    "OverlayRenderer()": "Constructor for the `OverlayRenderer`. It creates a transparent, click-through `JWindow` that covers the entire screen. It also initializes an `OverlayPanel` which is added to the window for custom painting. A key behavior is making the window always-on-top and non-focusable, ensuring it doesn't interfere with user input to other applications. This is instantiated by `Main` at startup.",
    "updateOverlays(List<DetectionResult>, List<DetectionResult>)": "The main public method for updating the visual feedback. It's called on every frame by the `DetectionEngine`. It clears all existing borders, then iterates through the `DetectionResult`s for the current and next steps, creating an `OverlayBorder` for each successfully found ability. It determines the correct color and thickness based on whether the ability is for the current or next step, and whether it's part of an 'OR' group. Finally, it triggers a repaint and manages the visibility of the overlay window.",
    "shutdown()": "A resource cleanup method that ensures the overlay is removed cleanly. It clears any active borders, then disposes of the underlying `JWindow` on the Swing Event Dispatch Thread. This is called by the shutdown hook in `Main` to free up graphics resources.",
    "OverlayPanel.paintComponent(Graphics)": "The core rendering method of the private inner `OverlayPanel`. It iterates through the `ConcurrentHashMap` of `activeBorders` and draws a colored, rounded rectangle for each one. It uses the color and thickness properties defined in the `BorderType` enum associated with each border. Antialiasing is enabled for smoother visuals. This method is what physically draws the feedback on the screen."
  },
  "ui.overlay.toast.ToastType": {
    "ToastType(...)": "The constructor for the `ToastType` enum. Each enum constant (SUCCESS, INFO, etc.) is initialized with a specific set of visual properties: an accent color, background color, foreground color, a Unicode icon, and a default display duration in milliseconds. This provides a centralized, type-safe way to define the different categories of toast notifications, ensuring a consistent look and feel across the application."
  },
  "ui.overlay.toast.ToastPanel": {
    "ToastPanel(ToastType, String, String)": "Constructor for the visual component representing a single toast notification. It takes the `ToastType` to determine its appearance and the message to display. It sets up the layout, configures the icon and message labels, and registers mouse listeners for interactions like dismissing the toast or opening a context menu. It's instantiated by the `ToastManager` for each new notification.",
    "paintComponent(Graphics)": "An overridden method that provides the custom look and feel of the toast. It uses `Graphics2D` to draw a rounded rectangle with a soft shadow and a colored accent strip on the left side, based on the `ToastType`. It also handles the panel's opacity, which is controlled by the `ToastManager`'s animation timers, allowing for smooth fade-in and fade-out effects.",
    "setOpacity(float)": "A public setter that controls the transparency of the toast panel. It's called repeatedly by the `ToastManager`'s animation `Timer` to create the fade-in and fade-out effects. It clamps the value between 0.0 and 1.0 and triggers a `repaint` to apply the new opacity in the `paintComponent` method."
  },
  "ui.overlay.toast.ToastManager": {
    "ToastManager(JFrame)": "Constructor for the high-level toast notification manager. It takes the main application `JFrame` as its owner. Its primary responsibility is to create and install a transparent `JPanel` onto the owner's `JLayeredPane`. This overlay panel serves as the container for all toast notifications. It also attaches listeners to handle owner window resizing and closing, ensuring the toasts are repositioned or cleared correctly. It is not currently used in the application but is available for future use.",
    "show(ToastType, String, String)": "The main public API for displaying a notification. It creates a `ToastRequest` and adds it to a pending queue. It then calls `processQueue` to manage the display of active toasts. This method is thread-safe and can be called from any thread, as it uses `SwingUtilities.invokeLater` to ensure all UI operations occur on the Event Dispatch Thread.",
    "processQueue()": "A private core method that manages the lifecycle of notifications. It runs on the EDT and checks if there is space to display a new toast (up to `MAX_VISIBLE`). If so, it pulls the next `ToastRequest` from the queue, creates a `ToastHandle` for it, adds the associated `ToastPanel` to the overlay, and then calls `layoutToasts` to position it correctly on the screen with an animation.",
    "layoutToasts(boolean)": "This private method is responsible for arranging the active toast notifications on the screen. It calculates the correct position for each toast, stacking them vertically from the bottom-right corner of the owner window. It calls the `updateTarget` method on each `ToastHandle` to either instantly move or animate the toast to its new position. This method is called whenever a toast is added or removed, or when the owner window is resized.",
    "ToastHandle.dismiss(boolean)": "A private method within the inner `ToastHandle` class that begins the process of removing a toast. It stops the lifetime timer and, if `animated` is true, it triggers the fade-out and slide-out animations. Once the animation is complete, it calls the `retire` method to permanently remove the toast from the screen."
  }
}