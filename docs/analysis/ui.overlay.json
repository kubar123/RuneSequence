{
  "ui.overlay.OverlayRenderer": {
    "OverlayRenderer()": "Constructor for the `OverlayRenderer`. It creates a transparent, click-through `JWindow` that covers the entire screen. It also initializes an `OverlayPanel` which is added to the window for custom painting. A key behavior is making the window always-on-top and non-focusable, ensuring it doesn't interfere with user input to other applications. This is instantiated by `Main` at startup.",
    "updateOverlays(List<DetectionResult>, List<DetectionResult>)": "The main public method for updating the visual feedback. It's called on every frame by the `DetectionEngine`. It clears all existing borders, then iterates through the `DetectionResult`s for the current and next steps, creating an `OverlayBorder` for each successfully found ability. It determines the correct color and thickness based on whether the ability is for the current or next step, and whether it's part of an 'OR' group. Finally, it triggers a repaint and manages the visibility of the overlay window.",
    "shutdown()": "A resource cleanup method that ensures the overlay is removed cleanly. It clears any active borders, then disposes of the underlying `JWindow` on the Swing Event Dispatch Thread. This is called by the shutdown hook in `Main` to free up graphics resources.",
    "OverlayPanel.paintComponent(Graphics)": "The core rendering method of the private inner `OverlayPanel`. It iterates through the `ConcurrentHashMap` of `activeBorders` and draws a colored, rounded rectangle for each one. It uses the color and thickness properties defined in the `BorderType` enum associated with each border. Antialiasing is enabled for smoother visuals. This method is what physically draws the feedback on the screen."
  },
  "ui.overlay.toast.ToastType": {
    "ToastType(...)": "The constructor for the `ToastType` enum. Each enum constant (SUCCESS, INFO, etc.) is initialized with a specific set of visual properties: an accent color, background color, foreground color, a Unicode icon, and a default display duration in milliseconds. This provides a centralized, type-safe way to define the different categories of toast notifications, ensuring a consistent look and feel across the application."
  },
  "ui.overlay.toast.ToastPanel": {
    "ToastPanel(ToastType, String, String)": "Constructor for the visual component representing a single toast notification. It takes the `ToastType` to determine its appearance and the message to display. It sets up the layout, configures the icon and message labels, and registers mouse listeners for interactions like dismissing the toast or opening a context menu. It's instantiated by the `ToastManager` for each new notification.",
    "paintComponent(Graphics)": "An overridden method that provides the custom look and feel of the toast. It uses `Graphics2D` to draw a rounded rectangle with a soft shadow and a colored accent strip on the left side, based on the `ToastType`. It also handles the panel's opacity, which is controlled by the `ToastManager`'s animation timers, allowing for smooth fade-in and fade-out effects.",
    "setOpacity(float)": "A public setter that controls the transparency of the toast panel. It's called repeatedly by the `ToastManager`'s animation `Timer` to create the fade-in and fade-out effects. It clamps the value between 0.0 and 1.0 and triggers a `repaint` to apply the new opacity in the `paintComponent` method."
  },
  "ui.overlay.toast.ToastManager": {
    "ToastManager(JFrame)": "Constructor for the high-level toast notification manager. It takes the main application `JFrame` and installs a transparent overlay `JPanel` into the frame's `JLayeredPane`, wiring component and window listeners so the overlay tracks resizes and is removed when the window closes. The manager now implements the `ToastClient` interface, making it the concrete UI-backed implementation for success, info, warning, and error messages in screens such as `PresetManagerWindow`.",
    "loggingFallback(Logger)": "A static factory that returns a `ToastClient` backed only by logging. It builds a lightweight implementation that maps success, info, warning, and error calls onto the supplied SLF4J `Logger`, formatting messages consistently. This is used as a safe default when the Swing UI has not yet been constructed, ensuring callers can always emit feedback without depending on the overlay being available.",
    "show(ToastType, String, String)": "The main public API for displaying a notification and the core implementation behind the `ToastClient` methods. It validates the arguments, enqueues a `ToastRequest`, and on the EDT calls `processQueue` to materialize up to a fixed number of visible toasts. If the owner frame has been disposed it silently clears the queue instead. The call is thread-safe: if invoked off the EDT it marshals work via `SwingUtilities.invokeLater`.",
    "clearAll()": "Implements the `ToastClient.clearAll` lifecycle hook. It switches to the EDT if necessary, dismisses all active `ToastHandle`s without running their fade-out animations, and clears the pending queue. This is invoked when the owner window is closing and can also be used by callers to instantly remove all notifications, ensuring no stale popups linger after major context changes.",
    "processQueue()": "A private core method that manages the lifecycle of notifications. It runs on the EDT and checks if there is space to display a new toast (up to `MAX_VISIBLE`). If so, it pulls the next `ToastRequest` from the queue, creates a `ToastHandle` for it, adds the associated `ToastPanel` to the overlay in the topmost z-order, and then calls `layoutToasts` to position it correctly with entry animations.",
    "layoutToasts(boolean)": "This private method is responsible for arranging the active toast notifications on the screen. It calculates the total stacked height, clamps each toast's width between configured minimum and maximum bounds, and anchors the stack to the bottom-right corner of the overlay. For existing toasts it optionally animates position changes; for new toasts it coordinates with `ToastHandle.updateTarget` to slide them in and fade them up to full opacity.",
    "ToastHandle.dismiss(boolean)": "A private method within the inner `ToastHandle` class that begins the process of removing a toast. It stops the lifetime timer, marks the handle as closing, and either animates both opacity and vertical position toward an off-screen target or retires the toast immediately. When the animation completes it calls back into `retireToast`, which removes the panel from the overlay and triggers re-layout of any remaining notifications."
  },
  "ui.overlay.toast.ToastClient": {
    "ToastClient": "A small UI-agnostic interface that standardizes how components report user-facing messages. It exposes symmetric `success`, `info`, `warn`, and `error` methods, each with overloads that accept an optional hidden diagnostic string, plus an optional `clearAll` lifecycle hook. Production code usually receives a `ToastManager` instance, which renders animated popups, while background or early-startup code can use the logging-only fallback provided by `ToastManager.loggingFallback`."
  }
}
