plugins {
    id 'java'
    id 'application'
}

version = '0.1.0'

def os = org.gradle.internal.os.OperatingSystem.current()
def isWindowsBuild = System.getProperty("os.name").toLowerCase().contains("win")

// CI-friendly defaults -------------------------------------------------------
// Users can override the cache directory in CI with ENV var JAVACPP_CACHE
def javacppCacheDir = System.getenv('JAVACPP_CACHE') ?: "${System.getProperty('user.home')}/.javacpp/cache"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

application {
    mainClass = 'com.lansoftprogramming.runeSequence.Main'  // Minimal test class
    applicationDefaultJvmArgs = [
            "-Xms512m",
            "-Xmx2048m",
            "--enable-native-access=ALL-UNNAMED",
            "-Dorg.bytedeco.javacpp.logger=slf4j"
    ]
}

def requiredJavaMajor = 25

def bundledRuntimeRoot = layout.buildDirectory.dir("bundled-runtime")
def packagedRuntimeImageDir = layout.buildDirectory.dir("runtime-image")
def packagedAppInputDir = layout.buildDirectory.dir("jpackage/input")
def packagedOutputDir = layout.buildDirectory.dir("jpackage/out")
def packagedAppImageName = (findProperty('rsAppName') ?: 'RuneSequence') as String
def packagedVendor = (findProperty('rsVendor') ?: 'LanSoft Programming') as String
def packagedDescription = (findProperty('rsDescription') ?: 'RuneSequence') as String
def packagedCopyright = (findProperty('rsCopyright') ?: 'Copyright (c) LanSoft Programming') as String
def packagedIconPath = (findProperty('rsIcon') ?: 'src/main/resources/icon.ico') as String
def packagedIconFile = file(packagedIconPath)
def packagedIconArgs = packagedIconFile.exists()
		? ['--icon', packagedIconFile.absolutePath]
		: []

def bundledRuntimeLauncher = javaToolchains.launcherFor {
	languageVersion = JavaLanguageVersion.of(requiredJavaMajor)
}

def isOnPath = { String exeName ->
	def path = System.getenv('PATH') ?: ''
	def parts = path.split(java.util.regex.Pattern.quote(File.pathSeparator))
	return parts.any { new File(it, exeName).exists() }
}

def wixToolsetPresent = os.isWindows() && (isOnPath('wix.exe') || (isOnPath('candle.exe') && isOnPath('light.exe')))

def javaToolExecutable = { String toolName ->
	def javaHome = bundledRuntimeLauncher.get().metadata.installationPath.asFile
	def exe = os.isWindows() ? "${toolName}.exe" : toolName
	return new File(new File(javaHome, "bin"), exe).absolutePath
}

tasks.named('jar').configure {
	manifest {
		attributes('Main-Class': application.mainClass.get())
	}
}

tasks.register('computeRuntimeModules') {
	dependsOn(tasks.named('jar'))

	def outputFile = layout.buildDirectory.file("runtime-modules.txt")
	outputs.file(outputFile)

	doLast {
		def appJar = tasks.named('jar').get().archiveFile.get().asFile
		def classpath = configurations.runtimeClasspath.files.collect { it.absolutePath }.join(File.pathSeparator)

		// Gradle 9 removed/locked down some legacy exec APIs from build scripts in some setups.
		// Use ProcessBuilder here for maximum compatibility.
		def cmd = [
				javaToolExecutable('jdeps'),
				'--ignore-missing-deps',
				'--multi-release', String.valueOf(requiredJavaMajor),
				'--print-module-deps',
				'--class-path', classpath,
				appJar.absolutePath
		]

		def proc = new ProcessBuilder(cmd)
				.redirectErrorStream(true)
				.start()
		def output = proc.inputStream.getText('UTF-8')
		proc.waitFor()

		def detected = (output ?: '').trim()

		// Conservative fallbacks: add Swing + common runtime pieces. (jlink will error if a module is invalid.)
		def fallback = [
				'java.base',
				'java.desktop',
				'java.logging',
				'java.management',
				'java.naming',
				'java.xml',
				'jdk.unsupported',
				'java.net.http'
		].join(',')

		def modules = (detected ? detected : fallback)
		outputFile.get().asFile.text = modules + System.lineSeparator()
	}
}

tasks.register('createRuntimeImage', Exec) {
	dependsOn(tasks.named('computeRuntimeModules'))
	outputs.dir(packagedRuntimeImageDir)

	doFirst {
		delete(packagedRuntimeImageDir)
	}

	doFirst {
		def modules = layout.buildDirectory.file("runtime-modules.txt").get().asFile.text.trim()
		args = [
				'--add-modules', modules,
				'--strip-debug',
				'--no-header-files',
				'--no-man-pages',
				'--compress', '2',
				'--bind-services',
				'--output', packagedRuntimeImageDir.get().asFile.absolutePath
		]
	}

	executable = javaToolExecutable('jlink')
}

tasks.register('prepareBundledRuntime', Sync) {
	dependsOn(tasks.named('createRuntimeImage'))
	from(packagedRuntimeImageDir)
	into(bundledRuntimeRoot)
}

distributions {
	main {
		contents {
			// Avoid confusion on Windows: `bin/RuneSequence` (the Unix script) shadows `bin/RuneSequence.bat`
			// when running `RuneSequence` from cmd.exe.
			if (isWindowsBuild) {
				def appName = application.applicationName ?: project.name
				exclude("bin/${appName}")
			}
			from(bundledRuntimeRoot) {
				into 'runtime'
			}
		}
	}
}

tasks.named('distZip').configure {
	dependsOn(tasks.named('prepareBundledRuntime'))
}
tasks.named('installDist').configure {
	dependsOn(tasks.named('prepareBundledRuntime'))
}

tasks.register('prepareJpackageInput', Sync) {
	dependsOn(tasks.named('jar'))
	into(packagedAppInputDir)

	from(tasks.named('jar')) {
		rename { "RuneSequence.jar" }
	}
	from(configurations.runtimeClasspath)
}

def jpackageJvmOptions = (application.applicationDefaultJvmArgs ?: []).collect { it as String }

tasks.register('jpackageAppImage', Exec) {
	dependsOn(tasks.named('createRuntimeImage'), tasks.named('prepareJpackageInput'))

	doFirst {
		delete(packagedOutputDir)
	}

	doFirst {
		def opts = []
		jpackageJvmOptions.each { opt ->
			opts += ['--java-options', opt]
		}

		args = [
				'--name', packagedAppImageName,
				'--app-version', String.valueOf(project.version),
				'--vendor', packagedVendor,
				'--description', packagedDescription,
				'--copyright', packagedCopyright,
				'--input', packagedAppInputDir.get().asFile.absolutePath,
				'--main-jar', 'RuneSequence.jar',
				'--main-class', application.mainClass.get(),
				'--runtime-image', packagedRuntimeImageDir.get().asFile.absolutePath,
				'--type', 'app-image',
				'--dest', packagedOutputDir.get().asFile.absolutePath
		] + packagedIconArgs + opts
	}

	executable = javaToolExecutable('jpackage')
}

tasks.register('jpackageExe', Exec) {
	onlyIf { os.isWindows() }
	dependsOn(tasks.named('createRuntimeImage'), tasks.named('prepareJpackageInput'))

	doFirst {
		if (!wixToolsetPresent) {
			throw new GradleException(
					"WiX Toolset not found on PATH. Install WiX (v3 candle.exe/light.exe or v4+ wix.exe) to build a Windows .exe installer, " +
							"or run `jpackageAppImage` to produce a portable app image without WiX."
			)
		}
		delete(packagedOutputDir)
	}

	doFirst {
		def opts = []
		jpackageJvmOptions.each { opt ->
			opts += ['--java-options', opt]
		}

		args = [
				'--name', packagedAppImageName,
				'--app-version', String.valueOf(project.version),
				'--vendor', packagedVendor,
				'--description', packagedDescription,
				'--copyright', packagedCopyright,
				'--input', packagedAppInputDir.get().asFile.absolutePath,
				'--main-jar', 'RuneSequence.jar',
				'--main-class', application.mainClass.get(),
				'--runtime-image', packagedRuntimeImageDir.get().asFile.absolutePath,
				'--type', 'exe',
				'--dest', packagedOutputDir.get().asFile.absolutePath,
				'--win-dir-chooser',
				'--win-shortcut',
				'--win-menu'
		] + packagedIconArgs + opts
	}

	executable = javaToolExecutable('jpackage')
}

tasks.register('jpackageZip', Zip) {
	// Portable zip for end users: does not require WiX. Produces build/distributions/RuneSequence-<version>-windows.zip (on Windows).
	onlyIf { os.isWindows() }
	dependsOn(tasks.named('jpackageAppImage'))

	from(packagedOutputDir) {
		include "${packagedAppImageName}/**"
	}
	// Keep Windows file timestamps (avoid the common "1980-02-01" zip epoch metadata).
	preserveFileTimestamps = true
	reproducibleFileOrder = true
	destinationDirectory = layout.buildDirectory.dir("distributions").get().asFile
	archiveBaseName = packagedAppImageName
	archiveVersion = String.valueOf(project.version)
	archiveClassifier = 'windows'
}

tasks.named('startScripts').configure {
	doLast {
		// Patch generated scripts so older Java versions fail with a clear message
		// (instead of crashing on unsupported JVM flags).
			if (windowsScript != null) {
				String text = windowsScript.getText('UTF-8')
				// Some environments disable cmd.exe "extensions"; Gradle's generated scripts rely on them
				// (%~dp0, %%~f, etc). Force-enable extensions for robustness on locked-down VMs.
				text = text.replace(
						'if "%OS%"=="Windows_NT" setlocal\r\n',
						'if "%OS%"=="Windows_NT" setlocal EnableExtensions\r\n'
				)
				// Quote critical path variables to avoid odd parsing failures on some systems.
				text = text.replace('set DIRNAME=%~dp0\r\n', 'set "DIRNAME=%~dp0"\r\n')
				text = text.replace('set APP_HOME=%DIRNAME%..\r\n', 'set "APP_HOME=%DIRNAME%.."\r\n')
				text = text.replace(
						'for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi\r\n',
						'for %%i in ("%APP_HOME%") do set "APP_HOME=%%~fi"\r\n'
				)
				// Windows batch files have a practical line-length limit; Gradle's generated
				// `set CLASSPATH=...` can exceed it with JavaCV/OpenCV dependencies.
				// Use Java's wildcard classpath to keep the launcher robust.
				text = text.replaceAll(
						'(?m)^set CLASSPATH=.*$',
						java.util.regex.Matcher.quoteReplacement('set CLASSPATH=%APP_HOME%\\lib\\*')
				)
				if (!text.contains("@rem Prefer bundled Java runtime if present")) {
					String marker = "@rem Find java.exe\r\n"
						String insert =
								"@rem Prefer bundled Java runtime if present\r\n" +
							"set \"BUNDLED_JAVA=%APP_HOME%\\runtime\\bin\\java.exe\"\r\n" +
							"if exist \"%BUNDLED_JAVA%\" (\r\n" +
							"  set \"JAVA_EXE=%BUNDLED_JAVA%\"\r\n" +
							"  goto execute\r\n" +
							")\r\n\r\n" +
						marker
				if (text.contains(marker)) {
					text = text.replace(marker, insert)
				}
			}
					if (!text.contains("Validate Java version (requires Java")) {
						String marker = ":execute\r\n"
						int idx = text.indexOf(marker)
							if (idx >= 0) {
								String insert =
										marker +
										"@rem Validate Java version (requires Java " + requiredJavaMajor + ")\r\n" +
										"set \"JAVA_VER_FILE=%TEMP%\\rune-sequence-java-version.txt\"\r\n" +
										"\"%JAVA_EXE%\" -version 1> \"%JAVA_VER_FILE%\" 2>&1\r\n" +
										"set \"JAVA_VER=\"\r\n" +
										"for /f \"usebackq tokens=3\" %%v in (\"%JAVA_VER_FILE%\") do (\r\n" +
										"  set \"JAVA_VER=%%v\"\r\n" +
										"  goto rsAfterJavaVersionRead\r\n" +
										")\r\n" +
										":rsAfterJavaVersionRead\r\n" +
										"del \"%JAVA_VER_FILE%\" >NUL 2>&1\r\n" +
										"set \"JAVA_VER=%JAVA_VER:\"=%\"\r\n" +
										"set \"JAVA_MAJOR=\"\r\n" +
										"for /f \"tokens=1 delims=.\" %%m in (\"%JAVA_VER%\") do set \"JAVA_MAJOR=%%m\"\r\n" +
										"if \"%JAVA_MAJOR%\"==\"1\" for /f \"tokens=2 delims=.\" %%m in (\"%JAVA_VER%\") do set \"JAVA_MAJOR=%%m\"\r\n" +
										"if not defined JAVA_MAJOR (\r\n" +
										"  echo.\r\n" +
										"  echo ERROR: Unable to determine Java version from: %JAVA_VER%\r\n" +
								"  echo.\r\n" +
								"  goto fail\r\n" +
								")\r\n" +
								"set /a JAVA_MAJOR_NUM=%JAVA_MAJOR% >NUL 2>&1\r\n" +
								"if %ERRORLEVEL% neq 0 (\r\n" +
								"  echo.\r\n" +
								"  echo ERROR: Unable to parse Java major version from: %JAVA_VER%\r\n" +
								"  echo.\r\n" +
								"  goto fail\r\n" +
								")\r\n" +
								"if %JAVA_MAJOR_NUM% LSS " + requiredJavaMajor + " (\r\n" +
								"  echo.\r\n" +
								"  echo ERROR: RuneSequence requires Java " + requiredJavaMajor + ". Detected Java %JAVA_VER%.\r\n" +
								"  echo.\r\n" +
								"  goto fail\r\n" +
								")\r\n\r\n"
						text = text.replace(marker, insert)
					}
				}
			windowsScript.setText(text, 'UTF-8')
		}

				if (unixScript != null) {
					String text = unixScript.getText('UTF-8')
					// Same rationale as Windows: avoid massive CLASSPATH lines.
					// Keep the wildcard quoted so Java expands it (not the shell).
					text = text.replaceAll(
							'(?m)^CLASSPATH=.*$',
							java.util.regex.Matcher.quoteReplacement('CLASSPATH="$APP_HOME/lib/*"')
					)
					if (!text.contains("runtime/bin/java")) {
						// Use single quotes to avoid Groovy GString interpolation of $JAVA_HOME.
						String marker = 'if [ -n "$JAVA_HOME" ] ; then\n'
							if (text.contains(marker)) {
							text = text.replace(
									marker,
									'# Prefer bundled Java runtime if present.\n' +
											'if [ -x "$APP_HOME/runtime/bin/java" ] ; then\n' +
											'    JAVACMD=$APP_HOME/runtime/bin/java\n' +
											'elif [ -n "$JAVA_HOME" ] ; then\n'
							)
						}
					}
			if (!text.contains("# Validate Java version (requires Java")) {
				String needle = "fi\n\n# Increase the maximum file descriptors if we can.\n"
				int idx = text.indexOf(needle)
					if (idx >= 0) {
						String insert =
								'fi\n\n' +
								'# Validate Java version (requires Java ' + requiredJavaMajor + ')\n' +
								'java_version_line=$("$JAVACMD" -version 2>&1 | head -n 1)\n' +
								'java_version=$(printf \'%s\\n\' "$java_version_line" | sed -n \'s/.*version "\\([^"]*\\)".*/\\1/p\')\n' +
								'java_major=${java_version%%.*}\n' +
								'if [ "$java_major" = "1" ]; then\n' +
								'  java_major=$(printf \'%s\\n\' "$java_version" | cut -d. -f2)\n' +
								'fi\n' +
								'case $java_major in\n' +
								'  \'\'|*[!0-9]*) die "ERROR: Unable to determine Java major version from: $java_version_line" ;;\n' +
								'esac\n' +
								'if [ "$java_major" -lt ' + requiredJavaMajor + ' ]; then\n' +
								'  die "ERROR: RuneSequence requires Java ' + requiredJavaMajor + '. Detected Java $java_version."\n' +
								'fi\n\n' +
								'# Increase the maximum file descriptors if we can.\n'
						text = text.replace(needle, insert)
						unixScript.setText(text, 'UTF-8')
					}
				}
			unixScript.setText(text, 'UTF-8')
		}
	}
}

repositories {
    mavenCentral()
}

dependencies {
	// Bytedeco "platform" artifacts bundle natives for multiple OSes and can be very large.
	// For Windows releases, use Windows-only natives to keep the installer size reasonable.
	def javacppVersion = '1.5.11'
	def opencvVersion = "4.10.0-${javacppVersion}"
	def ffmpegVersion = "7.1-${javacppVersion}"
	def openblasVersion = "0.3.28-${javacppVersion}"
	def leptonicaVersion = "1.85.0-${javacppVersion}"
	def tesseractVersion = "5.5.0-${javacppVersion}"

	if (os.isWindows()) {
		implementation "org.bytedeco:opencv:${opencvVersion}:windows-x86_64"
		implementation "org.bytedeco:ffmpeg:${ffmpegVersion}:windows-x86_64"
		// Some Bytedeco components (including parts of OpenCV/JavaCV pipelines) expect these native jars at runtime.
		implementation "org.bytedeco:openblas:${openblasVersion}:windows-x86_64"
		implementation "org.bytedeco:leptonica:${leptonicaVersion}:windows-x86_64"
		implementation "org.bytedeco:tesseract:${tesseractVersion}:windows-x86_64"
	} else {
		// Keep dev builds working on other OSes for now; can be tightened later per-platform.
		implementation "org.bytedeco:opencv-platform:${opencvVersion}"
		implementation "org.bytedeco:ffmpeg-platform:${ffmpegVersion}"
	}

    implementation 'org.bytedeco:javacv:1.5.11'

    //heybinds
    implementation 'com.1stleg:jnativehook:2.1.0'

    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.17'
    implementation 'ch.qos.logback:logback-classic:1.5.21'

    // JSON
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.20.0'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.20'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.20.0'

    // GUI
    implementation 'com.formdev:flatlaf:3.6.2'

    // Native window helpers (click-through overlays on Windows)
    implementation 'net.java.dev.jna:jna:5.16.0'
    implementation 'net.java.dev.jna:jna-platform:5.16.0'
    // Testing (JUnit Jupiter 5)
    testImplementation platform('org.junit:junit-bom:5.11.3')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    // Explicit launcher keeps Gradle's JUnit Platform happy when versions advance
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    systemProperty 'java.awt.headless', 'true'          // Avoid UI requirement in CI
    // Keep JavaCPP native extraction/cache location stable and writable in CI/WSL.
    systemProperty 'org.bytedeco.javacpp.cachedir', javacppCacheDir
    jvmArgs += ["--enable-native-access=ALL-UNNAMED"]
    testLogging {
        events "PASSED", "FAILED", "SKIPPED"
        showStandardStreams = System.getenv('CI') != null
        exceptionFormat 'short'
    }
}
tasks.withType(JavaExec).configureEach {
    jvmArgs += ["--enable-native-access=ALL-UNNAMED"]
    environment 'JAVACPP_CACHE', javacppCacheDir        // Keeps cache location consistent in CI
}
